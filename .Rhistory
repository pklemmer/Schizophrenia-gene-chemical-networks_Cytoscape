marked_cols <- as.list(getTableColumnNames()[!(getTableColumnNames() %in% c("selected","name.copy" ,"SUID","shared name","name","fromDisGeNET","fromWikiPathways","Ensembl","fromPublication","Publication.doi","CNVassociated","PathwayID","WPNodeID","WPNodeIDType","snpID","HGNCsymbol","DisGeNETname","disgenet_curated","gdascore","Entrez_gene"))])
lapply(marked_cols, function(column) {
deleteTableColumn(column=column)
})
#Filtering columns
renameNetwork("SCZ_SNW_STRING")
scz_snw_string <- getNetworkName()
exportNetwork(filename=paste0(nw_savepath,"SCZ_SNW_STRING"),"CX",network=scz_snw_string,overwriteFile=TRUE)
#Exporting the filtered, stringified supernetwork as cx file and tagging it with the time and data to match with the metadata file
end_section("STRING")
## CLUSTERING ----------------------------------------------------------------------------------------------------------------------
start_section("Clustering")
createColumnFilter(filter.name="delete.noensembl", column="Ensembl","ENSG","DOES_NOT_CONTAIN")
deleteSelectedNodes()
metadata.add(paste0("Ensembl nodes in supernetwork: ",getNodeCount()))
metadata.add("")
metadata.add("GLay Clustering")
metadata.add(capture.output(commandsRun('cluster glay clusterAttribute=__glayCluster createGroups=false network=current restoreEdges=true showUI=true undirectedEdges=true')))
#Clustering the network using the GLay community cluster from the clusterMaker Cytoscape app and recording outcome to metadata
renameNetwork("SCZ_SNW_STRING_clustered")
renameTableColumn('__glayCluster','gLayCluster')
#Renaming the newly generated gLayCluster column as the original name with two underscores is not recognized during gene ontology
snw_scz_string_clustered <- getNetworkName()
exportNetwork(filename=paste0(nw_savepath,"SCZ_SNW_STRING_clustered"),"CX",network=snw_scz_string_clustered,overwriteFile=TRUE)
#Exporting the filtered, stringified, clustered supernetwork as cx file and tagging it with the time and data to match with the metadata file
read_clustered_nodetable <- getTableColumns("node")
#Reading the exported csv
split_df <- split(read_clustered_nodetable$Ensembl,read_clustered_nodetable$gLayCluster)
#Splitting the node table by cluster
nodecount <- sapply(split_df, length)
#Counting how many nodes are in each cluster
countmatrix <- matrix(seq(1,length(nodecount)), ncol=1)
countmatrix <- cbind(countmatrix,as.numeric(nodecount))
#Construcing a matrix showing how many nodes are in each cluster
invalidclusters <- as.list(countmatrix[countmatrix[, 2] < 5, 1])
#Getting which clusters have fewer than 5 nodes associated with them
valid_clustered_nodetable <- read_clustered_nodetable[!read_clustered_nodetable$gLayCluster %in% invalidclusters, ]
#Generating a new df containing only nodes associated with clusters that had 5 or more nodes
split_tbl <- split(valid_clustered_nodetable, valid_clustered_nodetable$gLayCluster)
# test <- split_tbl[[1]]
# test2 <- test[, c("fromWikiPathways", "fromDisGeNET", "fromPublication")]
# colnames(test2) <- c("fromWikiPathways", "fromDisGeNET", "fromPublication")
#
# column_combinations_3 <- combn(colnames(test2),3,FUN=function(x) paste(x, collapse="_and_"))
# column_combinations_2 <- combn(colnames(test2),2,FUN=function(x) paste(x, collapse="_and_"))
# for (combination in column_combinations_2) {
#   test2[paste(combination,collapse="_and_")] <- test2[[combination[1]]] & test2[[combination[2]]]
# }
# for (combination in column_combinations_3) {
#   test2[paste(combination, collapse = "_")] <- test2[[combination[1]]] & test2[[combination[2]]] & test2[[combination[3]]]
# }
#
sourcecount <- function(cluster) {
wpcount <- sum(split_tbl[[cluster]][["fromWikiPathways"]] == 1, na.rm = TRUE)
dgcount <- sum(split_tbl[[cluster]][["fromDisGeNET"]] == 1, na.rm = TRUE)
litcount <- sum(split_tbl[[cluster]][["fromPublication"]] == 1, na.rm = TRUE)
result_df <- data.frame(
gLayCluster = split_tbl[[cluster]][["gLayCluster"]][1],
WikiPathways_source = wpcount,
DisGeNET_source = dgcount,
Publication_source = litcount
)
}
sources_count <- do.call(rbind, lapply(seq_along(split_tbl),sourcecount))
#For each cluster, counting how many nodes are associated with which sources
cnvassociatedcount <- function(cluster) {
cnvcount <- sum(split_tbl[[cluster]][["CNVassociated"]] == 1,na.rm=TRUE)
total_wp_nodes <- sources_count[sources_count$gLayCluster == split_tbl[[cluster]][["gLayCluster"]][1], "WikiPathways_source"]
non_cnv_count <- total_wp_nodes - cnvcount
result_df <- data.frame(
gLayCluster = split_tbl[[cluster]][["gLayCluster"]][1],
WikiPathways_CNV = cnvcount,
WikiPathways_noCNV = non_cnv_count
)
}
cnvassociated_count <- do.call(rbind,lapply(seq_along(split_tbl),cnvassociatedcount))
#For each cluster, count how many nodes originally come from CNV-associated pathways which pathways they come from
end_section("Clustering")
## GO ANALYSIS ------------------------------------------------------------------------------------------------------------------------
start_section("GO Analysis")
split_df <- split(valid_clustered_nodetable$Ensembl,valid_clustered_nodetable$gLayCluster)
split_list <- lapply(split_df, as.vector)
#Splitting the node table by cluster number, i.e. lists of Ensembl IDs are created per cluster
go <- function(cluster) {
gost(
query = cluster,
organism = "hsapiens",
ordered_query = FALSE,
multi_query = TRUE,
significant = TRUE,
exclude_iea = FALSE,
measure_underrepresentation = FALSE,
evcodes = FALSE,
user_threshold = 0.05,
correction_method = "g_SCS",
domain_scope ="annotated",
custom_bg = NULL,
numeric_ns = "",
sources = NULL,
as_short_link = FALSE,
highlight = TRUE
)
}
go_list <- lapply(split_list,go)
#Iterating the gost GO function over all clusters
get_top_terms <- function(cluster) {
terms <- toString(go_list[[cluster]][["result"]][["term_name"]][1:5])
#Extracting the top 5 term names associated with each cluster
pval <- toString(go_list[[cluster]][["result"]][["p_values"]][1:5])
#Extracting the p-values for the corresponding top 5 term names
nodes <- paste(go_list[[cluster]][["meta"]][["query_metadata"]][["queries"]][["query_1"]],collapse=",")
nnodes <- str_count(toString(go_list[[cluster]][["meta"]][["query_metadata"]][["queries"]][["query_1"]]),"\\S+")
#Extracing the number of nodes/genes contained in each cluster
result_df <- data.frame(
gLayCluster = cluster,
GO_Terms = terms,
GO_Pvals = pval,
Nodes = nodes,
N_nodes = nnodes
)
}
topterms_df <- do.call(rbind, lapply(names(go_list),get_top_terms))
#Getting top 5 term names and corresponding p-values for each cluster and storing in topterms_df
topterms_df <- cbind(topterms_df,sources_count,cnvassociated_count)
#joining the cluster table and the table detailing the amount of sources per cluster
write.table(topterms_df, file=paste0(other_savepath,"Clustering/GO-clusters-vis.tsv"), sep = "\t",row.names=FALSE,quote=FALSE)
#Writing the table to file for Cytoscape import during visualisation
loadTableData(topterms_df,data.key.column="gLayCluster",table.key.column="gLayCluster")
#Loading the generated top terms and p-values back to the supernetwork; every gene belonging to cluster x is now associated with the top terms of cluster x
deleteTableColumn('gLayCluster.1')
#Deleting duplicate gLayCluster column that appears after importing top terms data back to network
renameNetwork(title=paste0(getNetworkName(),"_GO"))
snw_scz_filtered_string_clustered_go <- getNetworkName()
#Renaming and saving the network name to indicate addition of GO information
compare_term_id_lists <- function(list1, list2) {
common_elements <- intersect(list1, list2)
return(length(common_elements))
}
#Setting up a function to get intersections between cluster term IDs
match_df <- data.frame(Cluster1 = character(),
Cluster2 = character(),
Matches = numeric(),
stringsAsFactors = FALSE)
#Setting up a df to store output in
for (i in 1:(length(go_list) - 1)) {
for (j in (i + 1):length(go_list)) {
term_id_i <- go_list[[i]][["result"]][["term_id"]]
term_id_j <- go_list[[j]][["result"]][["term_id"]]
matches <- compare_term_id_lists(term_id_i, term_id_j)
match_df <- rbind(match_df, data.frame(Cluster1 = names(go_list)[i],
Cluster2 = names(go_list)[j],
Matches = matches))
#Iterating over go_list to compare GO term IDs between every cluster and store number of overlaps
}
}
colnames(match_df) <- c("source","target","GO_term_matches")
#Renaming columns
write.table(match_df, file=paste0(other_savepath,"Clustering/match_df.tsv"), sep = "\t",row.names=FALSE,quote=FALSE)
exportNetwork(filename=paste0(nw_savepath,"SCZ_SNW_STRING_clustered_GO"),"CX",network=snw_scz_filtered_string_clustered_go,overwriteFile=TRUE)
#Exporting the filtered, stringified, clustered supernetwork after GO as cx file and tagging it with the time and data to match with the metadata file
end_section("GO Analysis")
##AOP ---------------------------------------------------------------------------------------------------------------------------
start_section("AOP")
aopprocess <- function(input,tag) {
if (!"SCZ_SNW_STRING_clustered_GO" %in% getNetworkList()) {
importNetworkFromFile(file=paste0(nw_savepath,"SCZ_SNW_STRING_clustered_GO.cx"))
commandsRun('table delete column column="gLayCluster.2" table="SCZ_SNW_STRING_clustered_GO default node')
createColumnFilter(
filter.name = "has_GO_result",
column = "N_nodes",
criterion = 0,
predicate = "GREATER_THAN",
anyMatch = TRUE,
apply = TRUE
)
#Selecting nodes included in a 'valid' cluster, i.e. clusters with 5 or more nodes (GO analysis only performed for these)
#N_nodes is only generated for 'valid' clusters, so good column to filter by
invertNodeSelection()
deleteSelectedNodes()
#Inverting the selection and deleting these nodes: now, the network contains only the nodes that make up the clusters fed into the GO analysis
#Nodes not associated to a large enough cluster/GO term are likely not involved in any significant SCZ-contributing way
#The idea is to link GO terms (formed by clusters/genes) to risk factors, so it wouldn't make sense to also link non-cluster/GO associated nodes
}
else {
commandsRun('table delete column column="gLayCluster.2" table="SCZ_SNW_STRING_clustered_GO default node')
createColumnFilter(
filter.name = "has_GO_result",
column = "N_nodes",
criterion = 0,
predicate = "GREATER_THAN",
anyMatch = TRUE,
apply = TRUE
)
#Selecting nodes included in a 'valid' cluster, i.e. clusters with 5 or more nodes (GO analysis only performed for these)
#N_nodes is only generated for 'valid' clusters, so good column to filter by
invertNodeSelection()
deleteSelectedNodes()
#Inverting the selection and deleting these nodes: now, the network contains only the nodes that make up the clusters fed into the GO analysis
#Nodes not associated to a large enough cluster/GO term are likely not involved in any significant SCZ-contributing way
#The idea is to link GO terms (formed by clusters/genes) to risk factors, so it wouldn't make sense to also link non-cluster/GO associated nodes
}
#Reimporting the network with GO information back to Cytoscape if needed
#Running aopprocess causes all changes to be applied to the GO network
#Running aopprocess a second time with other parameters would thus compound changes into the same network which is undesired
sparqlquery("AOP-Wiki",input,"keensgpairs")
#Querying AOP-Wiki for a list of all KEs and associated genes. KEs must be contained in an AOP that has an AO from a list of selected AOs
#Explicity listing keensgpairs so that it is caught by ls()
for (i in 1:ncol(keensgpairs)) {
for (j in 1:nrow(keensgpairs)) {
keensgpairs[j, i] <- gsub('"', '', keensgpairs[j, i])
}
}
#Removing quotation marks from the df
separate_keensgpairs <- separate_rows(keensgpairs,Ensembl,sep="; ")
#Dividing comma-separated Ensembl IDs into distinct rows
keensgpairs_byensg <- separate_keensgpairs %>%
group_by(Ensembl) %>%
summarise(KEid = paste(KEid, collapse="; "),
AOPid = paste(AOPid, collapse="; "))
#Concatenating other variables based on unique Ensembl ID to get list of associated KEs and AOPs per gene
keensgpairs_byensg_save <- paste0(other_savepath,sprintf("AOP-Wiki/keensgpairs_byensg_%s.tsv",tag))
#Defining savepath for newly generated df
write.table(keensgpairs_byensg, file=keensgpairs_byensg_save,quote=FALSE, sep="\t", row.names=FALSE)
#Saving df containing gene-KE-AO-AOP associations to file as tsv for Cytoscape import
commandsRun(sprintf('table import file dataTypeTargetforNetworkCollection="Node Table Columns" delimiters=\\t file=%s firstRowAsColumnNames=true keyColumnForMapping="Ensembl" keyColumnIndex=1 startLoadRow=1',keensgpairs_byensg_save))
#Importing the gene-KE-AO-AOP table to Cytoscape as table add AOP-Wiki info as node attributes
renameNetwork(paste0(getNetworkName(),"_AOP"))
scz_snw_string_go_aop <- getNetworkName()
scz_snw_string_go_aop_node <- getTableColumns("node")
#Reading the exported table as Cytoscape object
aop_associated_genes <- scz_snw_string_go_aop_node[!(scz_snw_string_go_aop_node$KEid == ""), , drop=FALSE]
#Getting which rows (=gene nodes) have info from AOP-Wiki associated to them
renameNetwork(paste0(getNetworkName(),"_",tag))
summary_go_terms <- read.delim(paste0(getwd(),"/Data/summary_go_terms.txt"),header=TRUE,sep="\t",quote="")
#Loading cluster titles based on GO terms
aop_associated_genes <- merge(aop_associated_genes,summary_go_terms,"gLayCluster")
Sys.sleep(1)
separate_ketitles <- separate_rows(aop_associated_genes,KEid,sep="; ")
ke_freq_table <- table(separate_ketitles$KEid)
ke_freq_df <- as.data.frame(ke_freq_table)
add_attributes <- separate_ketitles %>%
group_by(KEid) %>%
summarise (KEEnsembl = paste(Ensembl,collapse="; "),
KEgenename = paste(HGNCsymbol, collapse="; "),
KEsummary_go_term = paste(summary_term, collapse="; "))
names(ke_freq_df) <- c("KEid","KE_frequency")
ke_freq_df_full <- merge(ke_freq_df, add_attributes,"KEid")
#Counting how often which KEs are associated with all genes
ke_associated_genes_freq <- ke_freq_df_full
aop_link <- list()
variables <- ls()
#Getting a list of variables defined within the aopprocess function
#append_suffix <- function(variable, suffix) {
#assign(paste0(variable,"_",suffix), get(variable), envir = .GlobalEnv)
#}
#Defining a function to add a suffix to the variables created within the aopprocess function
for (variable in variables) {
aop_link[[variable]] <- get(variable)
}
return(aop_link)
#Appending the given tag to every produced variable within the aopprocess function
#Saving the resulting network
}
aoplink_all <- aopprocess("all_AO_KE_Ensembl_query.txt","all")
#Matching AOP information to risk genes in the network from all AOs available in AOP-Wiki
snw_scz_string_clustered_GO_AOP_all <- getNetworkName()
exportNetwork(filename=paste0(nw_savepath,"SCZ_SNW_STRING_clustered_GO_AOP_all"),"CX",network=snw_scz_string_clustered_GO_AOP_all,overwriteFile=TRUE)
#Exporting network
nclusters <- as.character(count(unique(getTableColumns("node","gLayCluster"))))
#Counting how many valid clusters remain
metadata.add(paste0("Valid (>= 5 nodes) clusters: ",nclusters))
metadata.add(paste0("Nodes associated with valid clusters: ",getNodeCount()))
metadata.add("")
gettop <- function(input) {
freq_df <- input$ke_freq_df_full
#cutoff_ke <- quantile(freq_df$KE_frequency, probs=0.75,na.rm = TRUE)
#Defining cutoff for KE frequency (top 25% most frequent)
#topquarter_ke <- freq_df[freq_df$KE_frequency >= cutoff_ke & !is.na(freq_df$KE_frequency),,drop=FALSE]
#Selecting the top 25% most frequently matched with KEs and associated information
topquarter_ke <- freq_df
}
top_all <- gettop(aoplink_all)
View(top_all)
View(aoplink_all)
View(keensgpairs)
getkegenepairs <- function(input) {
topquarter_ke <- input
topquarter_ke_sep <- separate_rows(topquarter_ke,KEEnsembl,sep="; ")
mergedkeensg <- union(topquarter_ke_sep$KEid,topquarter_ke_sep$KEEnsembl)
#topquarter_ke_node <- data.frame(combined=mergedkeensg)
topquarter_ke<- topquarter_ke_sep[,c("KEid","KEEnsembl")]
topquarter_ke <- topquarter_ke %>%
rename(KEid_source = KEid,
KEEnsembl_target = KEEnsembl)
#Renaming columns to source and target for Cytoscape import
topquarter_ke$KEid <- topquarter_ke$KEid_source
topquarter_ke$Ensembl <- topquarter_ke$KEEnsembl_target
#Creating duplicate columns of KEid and KEEnsembl to be used as source and target attributes
#This allows new columns in the network to easily select Ensembl and KE nodes separately etc.
#Without this, both KE and Ensembl nodes are stored in the 'names' column due to how Cytoscape import works
sparqlquery("AOP-Wiki","kemap.txt","kemap")
#Running query to get KEid-title mappings
for (i in 1:ncol(kemap)) {
for (j in 1:nrow(kemap)) {
kemap[j, i] <- gsub('"', '', kemap[j, i])
}
}
#Removing quotation marks from df
topquarter_ke <- merge(topquarter_ke,kemap,by="KEid",all.x=FALSE)
#Merging the mapping and node tables to extend node table with KE titles
topquarter_ke <- topquarter_ke[,c("KEid_source","KEEnsembl_target","KEid","KEtitle","Ensembl")]
#Reordering table columns
#write.table(topquarter_ke_node, file=paste0(getwd(),"/topquarter_ke_node.tsv"),sep="\t",quote=FALSE,row.names=FALSE)
write.table(topquarter_ke, file=paste0(other_savepath,sprintf("AOP-Wiki/topquarter_ke_edge%s.tsv",sub("top","",deparse(substitute(input))))),sep="\t",quote=FALSE,row.names=FALSE)
#Writing the KE-gene table to file for Cytoscape import
commandsRun(sprintf('network import file columnTypeList=s,t,sa,sa,ta delimiters=\\t file=%s firstRowAsColumnNames=true rootNetworkList=-- Create new network collection -- startLoadRow=1',paste0(other_savepath,sprintf("AOP-Wiki/topquarter_ke_edge%s.tsv",sub("top","",deparse(substitute(input)))))))
#Importing as network
Sys.sleep(0.5)
renameNetwork(sprintf("Top quarter key events - risk genes%s",sub("top","",deparse(substitute(input)))))
}
getkegenepairs(top_all)
kegenenetwork_all <- getNetworkName()
getkeaoppairs <- function(input) {
keaoppairs <- keensgpairs[keensgpairs$KEid %in% input$KEid,c("KEid","AOPid")]
#For top quarter KEs, get which AOPs these are taken from from result of initial AOP-Wiki query
keaoppairs <- separate_rows(keaoppairs,AOPid,sep="; ")
sparqlquery("AOP-Wiki","aopmap.txt","aopmap")
#Running query to get AOPid-title mappings
for (i in 1:ncol(aopmap)) {
for (j in 1:nrow(aopmap)) {
aopmap[j, i] <- gsub('"', '', aopmap[j, i])
}
}
#Removing quotation marks from df
keaoppairs <- merge(keaoppairs,aopmap,by="AOPid",all.x=FALSE)
#Mapping AOPids to AOPtitles using mapping file
keaoppairs <- keaoppairs %>%
rename(KEid_target = KEid,
AOPid_source = AOPid)
#Renaming columns in preparation for import
keaoppairs$KEid <- keaoppairs$KEid_target
keaoppairs$AOPid <- keaoppairs$AOPid_source
#Creating duplicate columns of KEid and AOPid to be used as source and target attributes
#This allows new columns in the network to easily select AOP and KE nodes separately etc.
#Without this, both KE and AOP nodes are stored in the 'names' column due to how Cytoscape import works
keaoppairs <- keaoppairs[,c("KEid_target","KEid","AOPid_source","AOPid","AOPtitle")]
#Reordering columns
write.table(keaoppairs,file=paste0(other_savepath,sprintf("AOP-Wiki/keaoppairs%s.tsv",sub("top","",deparse(substitute(input))))),sep="\t",quote=FALSE,row.names=FALSE)
#Writing modified table to file
commandsRun(sprintf('network import file columnTypeList=t,ta,s,sa,sa delimiters=\\t file=%s firstRowAsColumnNames=true rootNetworkList= -- Create new network collection -- startLoadRow=1',paste0(other_savepath,sprintf("AOP-Wiki/keaoppairs%s.tsv",sub("top","",deparse(substitute(input)))))))
#Importing as network
Sys.sleep(0.5)
renameNetwork(sprintf("Top quarter key events - AOPs%s",sub("top","",deparse(substitute(input)))))
}
getkeaoppairs(top_all)
keaopnetwork_all <- getNetworkName()
getaopaopairs <- function(input) {
keaoppairs <- keensgpairs[keensgpairs$KEid %in% input$KEid,"AOPid"]
keaoppairs <- unique(separate_rows(keaoppairs,AOPid,sep="; "))
#For top quarter KEs, get which unique AOPs these are taken from
sparqlquery("AOP-Wiki","aopao.txt","aopao")
#Getting full list of which AOs are associated to which AOPs
aopaopairs <- aopao[aopao$AOPid %in% keaoppairs$AOPid,]
#Filtering AOP-AO list by AOPs associated with top quarter KEs
sparqlquery("AOP-Wiki","aopmap.txt","aopmap")
#Running query to get AOPid-title mappings
for (i in 1:ncol(aopmap)) {
for (j in 1:nrow(aopmap)) {
aopmap[j, i] <- gsub('"', '', aopmap[j, i])
}
}
#Removing quotation marks from df
aopaopairs <- merge(aopaopairs,aopmap,by="AOPid",all.x=FALSE)
#Mapping AOPids to AOPtitles using mapping file
sparqlquery("AOP-Wiki","aomap.txt","aomap")
for (i in 1:ncol(aomap)) {
for (j in 1:nrow(aomap)) {
aomap[j, i] <- gsub('"', '', aomap[j, i])
}
}
#Removing quotation marks from df
aopaopairs <- merge(aopaopairs,aomap,by="AOid",all.x=FALSE)
#Mapping AOids to AOtitles using mapping file
aopaopairs <- aopaopairs %>%
rename(AOPid_target = AOPid,
AOid_source = AOid)
#Renaming columns in preparation for import
aopaopairs$AOid <- aopaopairs$AOid_source
aopaopairs$AOPid <- aopaopairs$AOPid_target
#Creating duplicate columns of AOid and AOPid to be used as source and target attributes
#This allows new columns in the network to easily select AOid and AOPid nodes separately etc.
#Without this, both AO and AOP nodes are stored in the 'names' column due to how Cytoscape import works
aopaopairs$index <- NA
#Creating an empty placeholder column that is to be filled with copies of row values from the SUID column; explained more in mergeaop function later
#Must be created in df that then becomes a network, since creating a column using the Cytoscape command line will result in an 'invisible' column that cannot be used as key for merging tables
aopaopairs <- aopaopairs[,c("AOid_source","AOPid_target","AOid","AOtitle","AOPid","AOPtitle","index")]
#Reordering columns
write.table(aopaopairs,file=paste0(other_savepath,sprintf("AOP-Wiki/aopaopairs%s.tsv",sub("top","",deparse(substitute(input))))),sep="\t",quote=FALSE,row.names=FALSE)
#Writing modified table to file
commandsRun(sprintf('network import file columnTypeList=s,t,sa,sa,ta,ta,ta delimiters=\\t file=%s firstRowAsColumnNames=true rootNetworkList= -- Create new network collection -- startLoadRow=1',paste0(other_savepath,sprintf("AOP-Wiki/aopaopairs%s.tsv",sub("top","",deparse(substitute(input)))))))
#Importing table as network
Sys.sleep(0.5)
renameNetwork(sprintf("AOP-AO pairs for top AOPs in top quarter KEs%s",sub("top","",deparse(substitute(input)))))
}
# getaopaopairs(top_selected)
# aopaonetwork_selected <- getNetworkName()
getaopaopairs(top_all)
aopaonetwork_all <- getNetworkName()
mergeaop <- function (input){
aopaonetwork <- get(paste0("aopaonetwork_",input))
keaopnetwork <- get(paste0("keaopnetwork_", input))
kegenenetwork <- get(paste0("kegenenetwork_",input))
#Renaming variables to contain type of selection to correctly select previously generated objects
altmergeNetworks(sources=c(aopaonetwork,keaopnetwork),
title = "KE-AOP-AO merged network",
operation="union",
nodeKeys=c("AOPid","AOPid"))
renameNetwork(paste0("KE-AOP-AO merged network_",input))
#Merging the AOP-AO network to the KE-AOP network to extend KE-AOP associations with AOs
keaopaomerged <- getNetworkName()
altmergeNetworks(sources=c(keaopaomerged,kegenenetwork),
title="gene-KE-AOP-AO merged network",
operation="union",
nodeKeys=c("KEid","KEid"))
#Merging KE-AOP-AO associations with the KE-gene network to extend KE-gene associations with AOPs and AOs
renameNetwork(paste0("gene-KE-AOP-AO merged network_",input))
mergedaopnode <- getTableColumns("node","Ensembl")
#Getting values in the Ensembl column of AOP network
input <- data.frame(
source = rep("En", length(mergedaopnode[, 1])),
identifier = mergedaopnode[, 1]
)
#Making a new df to be used as input for bridgedb
#Map Ensembl ID
mergedaopnode_map <- maps(mapper,input,"H")
#Mapping from Ensembl to HGNC
mergedaopnode_map <- select(mergedaopnode_map, c("identifier", "mapping"))
mergedaopnode_map <- rename(mergedaopnode_map,
Ensembl = identifier,
HGNCsymbol = mapping)
#Selecting and renaming relevant columns from bridgeDb mapping output
loadTableData(mergedaopnode_map,
data.key.column = "Ensembl",
table = "node",
table.key.column = "Ensembl")
#loading HGNC names for Ensembl IDs in AOP network back to node table
nodetable <- getTableColumns("node",c("KEtitle","AOPtitle","AOtitle","HGNCsymbol","SUID"))
nodetable <- nodetable %>%
rowwise() %>%
mutate(label=paste(na.omit(c_across(all_of(c("KEtitle","AOPtitle","AOtitle","HGNCsymbol")))), collapse=""))
#Generating a new 'label' column that combines KEtitle, AOPtitle, AOtitle, and HGNC into one columns
#Since each node represents a different type of data (KE, AOP, AO, or gene), titles will never overlap
#Cytoscape visualisation is based on one column, thus labels need to all be stored in a single column for visualisation
nodetable <- nodetable %>%
rowwise() %>%
mutate(type = case_when(
str_detect(AOPtitle, "\\S") ~ "AOP",
str_detect(AOtitle, "\\S") ~ "AO",
str_detect(KEtitle, "\\S") ~ "KE",
str_detect(HGNCsymbol, "\\S") ~ "gene",
TRUE ~ NA_character_
))
#Generating a new 'type' column indicating of which type (KE, AOP, AO, or gene) a node is
#Again for visualsation purposes - later used to determine color mapping of node based on type
loadTableData(nodetable,"SUID","node","SUID")
lapply(c(aopaonetwork,keaopnetwork,kegenenetwork,keaopaomerged),deleteNetwork)
#Deleting intermediary networks used to generate full gene-KE-AOP-AO network
}
mergeaop("all")
#Creating the full gene-KE-AOP-AO network with data from all AOs and associated AOPs and KEs in AOP-Wiki
aopmerged_node <- getTableColumns("node")
sparqlquery("AOP-Wiki","miemap.txt","miemap")
sparqlquery("AOP-Wiki","miemap.txt","miemap")
#Getting a list of all data points in AOP-Wiki tagged as molecular initiating events and the AOPs for which they are MIEs
aopmerged_node_KEid <- aopmerged_node$KEid
#Getting a list of all data points in AOP-Wiki tagged as molecular initiating events and the AOPs for which they are MIEs
aopmerged_node_KEid <- as.data.frame(aopmerged_node$KEid)
View(aopmerged_node_KEid)
#Getting list of key event nodes in the merged network
KEid_mie <- merge(aopmerged_node_KEid, miemap, by="KEid", all = TRUE)
#Getting list of key event nodes in the merged network
KEid_mie <- merge(aopmerged_node_KEid, miemap, by=KEid, all = TRUE)
View(aopmerged_node_KEid)
aopmerged_node$KEid
#Getting list of key event nodes in the merged network
names(aopmerged_node_KEid) = "KEid"
#Getting a list of all data points in AOP-Wiki tagged as molecular initiating events and the AOPs for which they are MIEs
aopmerged_node_KEid <- as.data.frame(aopmerged_node$KEid)
#Getting list of key event nodes in the merged network
names(aopmerged_node_KEid) = "KEid"
KEid_mie <- merge(aopmerged_node_KEid, miemap, by="KEid", all = TRUE)
View(KEid_mie)
aopmerged_node_KEid <- na.remove()
#Creating the full gene-KE-AOP-AO network with data from all AOs and associated AOPs and KEs in AOP-Wiki
aopmerged_node <- getTableColumns("node")
sparqlquery("AOP-Wiki","miemap.txt","miemap")
#Getting a list of all data points in AOP-Wiki tagged as molecular initiating events and the AOPs for which they are MIEs
aopmerged_node_KEid <- as.data.frame(aopmerged_node$KEid)
#Getting list of key event nodes in the merged network
names(aopmerged_node_KEid) = "KEid"
aopmerged_node_KEid <- na.omit()
aopmerged_node_KEid <- na.omit(aopmerged_node_KEid)
View(aopmerged_node_KEid)
KEid_mie <- merge(aopmerged_node_KEid, miemap, by="KEid", all = TRUE)
View(KEid_mie)
KEid_mie <- merge(aopmerged_node_KEid, miemap, by="KEid", all.y=TRUE)
View(KEid_mie)
KEid_mie <- merge(aopmerged_node_KEid, miemap, by="KEid", all.x=TRUE)
View(KEid_mie)
?loadTableData
#Mapping in which AOPs the KEs in the network appear as MIEs
loadTableData(KEid_mie,"KEid","node","KEid")
