AOid_source = AOid)
#Renaming columns in preparation for import
aopaopairs$AOid <- aopaopairs$AOid_source
aopaopairs$AOPid <- aopaopairs$AOPid_target
#Creating duplicate columns of AOid and AOPid to be used as source and target attributes
#This allows new columns in the network to easily select AOid and AOPid nodes separately etc.
#Without this, both AO and AOP nodes are stored in the 'names' column due to how Cytoscape import works
aopaopairs$index <- NA
#Creating an empty placeholder column that is to be filled with copies of row values from the SUID column; explained more in mergeaop function later
#Must be created in df that then becomes a network, since creating a column using the Cytoscape command line will result in an 'invisible' column that cannot be used as key for merging tables
aopaopairs <- aopaopairs[,c("AOid_source","AOPid_target","AOid","AOtitle","AOPid","AOPtitle","index")]
#Reordering columns
write.table(aopaopairs,file=paste0(other_savepath,sprintf("AOP-Wiki/aopaopairs%s.tsv",sub("top","",deparse(substitute(input))))),sep="\t",quote=FALSE,row.names=FALSE)
#Writing modified table to file
commandsRun(sprintf('network import file columnTypeList=s,t,sa,sa,ta,ta,ta delimiters=\\t file=%s firstRowAsColumnNames=true rootNetworkList= -- Create new network collection -- startLoadRow=1',paste0(other_savepath,sprintf("AOP-Wiki/aopaopairs%s.tsv",sub("top","",deparse(substitute(input)))))))
#Importing table as network
Sys.sleep(0.5)
renameNetwork(sprintf("AOP-AO pairs for top AOPs in top quarter KEs%s",sub("top","",deparse(substitute(input)))))
}
# getaopaopairs(top_selected)
# aopaonetwork_selected <- getNetworkName()
getaopaopairs(top_all)
aopaonetwork_all <- getNetworkName()
mergeaop <- function (input){
aopaonetwork <- get(paste0("aopaonetwork_",input))
keaopnetwork <- get(paste0("keaopnetwork_", input))
kegenenetwork <- get(paste0("kegenenetwork_",input))
#Renaming variables to contain type of selection to correctly select previously generated objects
altmergeNetworks(sources=c(aopaonetwork,keaopnetwork),
title = "KE-AOP-AO merged network",
operation="union",
nodeKeys=c("AOPid","AOPid"))
renameNetwork(paste0("KE-AOP-AO merged network_",input))
#Merging the AOP-AO network to the KE-AOP network to extend KE-AOP associations with AOs
keaopaomerged <- getNetworkName()
altmergeNetworks(sources=c(keaopaomerged,kegenenetwork),
title="gene-KE-AOP-AO merged network",
operation="union",
nodeKeys=c("KEid","KEid"))
#Merging KE-AOP-AO associations with the KE-gene network to extend KE-gene associations with AOPs and AOs
renameNetwork(paste0("gene-KE-AOP-AO merged network_",input))
mergedaopnode <- getTableColumns("node","Ensembl")
#Getting values in the Ensembl column of AOP network
input <- data.frame(
source = rep("En", length(mergedaopnode[, 1])),
identifier = mergedaopnode[, 1]
)
#Making a new df to be used as input for bridgedb
#Map Ensembl ID
mergedaopnode_map <- maps(mapper,input,"H")
#Mapping from Ensembl to HGNC
mergedaopnode_map <- select(mergedaopnode_map, c("identifier", "mapping"))
mergedaopnode_map <- rename(mergedaopnode_map,
Ensembl = identifier,
HGNCsymbol = mapping)
#Selecting and renaming relevant columns from bridgeDb mapping output
loadTableData(mergedaopnode_map,
data.key.column = "Ensembl",
table = "node",
table.key.column = "Ensembl")
#loading HGNC names for Ensembl IDs in AOP network back to node table
nodetable <- getTableColumns("node",c("KEtitle","AOPtitle","AOtitle","HGNCsymbol","SUID"))
nodetable <- nodetable %>%
rowwise() %>%
mutate(label=paste(na.omit(c_across(all_of(c("KEtitle","AOPtitle","AOtitle","HGNCsymbol")))), collapse=""))
#Generating a new 'label' column that combines KEtitle, AOPtitle, AOtitle, and HGNC into one columns
#Since each node represents a different type of data (KE, AOP, AO, or gene), titles will never overlap
#Cytoscape visualisation is based on one column, thus labels need to all be stored in a single column for visualisation
nodetable <- nodetable %>%
rowwise() %>%
mutate(type = case_when(
str_detect(AOPtitle, "\\S") ~ "AOP",
str_detect(AOtitle, "\\S") ~ "AO",
str_detect(KEtitle, "\\S") ~ "KE",
str_detect(HGNCsymbol, "\\S") ~ "gene",
TRUE ~ NA_character_
))
#Generating a new 'type' column indicating of which type (KE, AOP, AO, or gene) a node is
#Again for visualsation purposes - later used to determine color mapping of node based on type
loadTableData(nodetable,"SUID","node","SUID")
lapply(c(aopaonetwork,keaopnetwork,kegenenetwork,keaopaomerged),deleteNetwork)
#Deleting intermediary networks used to generate full gene-KE-AOP-AO network
}
mergeaop("all")
#Creating the full gene-KE-AOP-AO network with data from all AOs and associated AOPs and KEs in AOP-Wiki
aopmerged_node <- getTableColumns("node")
sparqlquery("AOP-Wiki","miemap.txt","miemap")
#Getting a list of all data points in AOP-Wiki tagged as molecular initiating events and the AOPs for which they are MIEs
aopmerged_node_KEid <- as.data.frame(aopmerged_node$KEid)
#Getting list of key event nodes in the merged network
names(aopmerged_node_KEid) = "KEid"
aopmerged_node_KEid <- na.omit(aopmerged_node_KEid)
#Df cleanup
KEid_mie <- merge(aopmerged_node_KEid, miemap, by="KEid", all.x=TRUE)
#Mapping in which AOPs the KEs in the network appear as MIEs
loadTableData(KEid_mie,"KEid","node","KEid")
#Loading MIE mapping back to the network
KEid_mie <- na.omit(KEid_mie[!is.na(KEid_mie[["KEisMIEin"]]), ])
#Removing non-MIE rows
KEid_mie <- separate_rows(KEid_mie, KEisMIEin, sep = "; ")
#Separating rows to show one KE being an MIE in a specific AOP per row
KEid_mie$interaction <- paste(KEid_mie$KEisMIEin, "(interacts with)", KEid_mie$KEid)
#Generating a new column that follows Cytoscape edge nomenclature to be used as key column
KEid_mie$isMIEedge <- 1
#Adding column showing whether the edge is related to a MIE or not, used in visualisation
loadTableData(KEid_mie, "interaction","edge","name")
#Loading edge info back to network
exportNetwork(paste0(nw_savepath,"gene-KE-AOP-AO merged network_all"),"CX", overwriteFile=TRUE,network="gene-KE-AOP-AO merged network_all")
#Exporting the network
end_section("AOP-Wiki extension")
##Cluster/pathway extesion -----------------------------------------------------------------------------------------------------------------------------------------
start_section("Cluster/pathway extension")
importNetworkFromFile(paste0(nw_savepath,"SCZ_SNW_STRING_clustered_GO.cx"))
#Reimporting clustered supernetwork with GO results added
commandsRun('table delete column column="gLayCluster.2" table="SCZ_SNW_STRING_clustered_GO default node')
#Deleting duplicate gLayCluster column
createColumnFilter(
filter.name = "has_GO_result",
column = "N_nodes",
criterion = 0,
predicate = "GREATER_THAN",
anyMatch = TRUE,
apply = TRUE
)
#Selecting nodes included in a 'valid' cluster, i.e. clusters with 5 or more nodes (GO analysis only performed for these)
#N_nodes is only generated for 'valid' clusters, so good column to filter by
invertNodeSelection()
deleteSelectedNodes()
#Inverting selection and deleting nodes that don't have GO results
snw_node <- getTableColumns("node")
deleteNetwork("SCZ_SNW_STRING_clustered_GO")
#Deleting the SNW again, was only imported to get node table
snw_node_aop <- snw_node[snw_node$Ensembl %in% aopmerged_node$Ensembl,]
#Selecting rows from snw_node_aop that have the same genes that are also found in the AOP network
remove_duplicates <- function(pathway_string) {
pathway_string %>%
str_split(";|, ") %>%     # Split the string by commas or semicolons
unlist() %>%              # Unlist the resulting list
unique() %>%              # Remove duplicates
paste(collapse = ", ")    # Collapse the unique elements back into a single string
}
#When merging WikiPathways node and edge networks, it's possible that there are semi-colon separated duplicates in PathwayID
#This function splits strings and removes duplicates for a more consistent and clean look
snw_node_aop$PathwayID <- sapply(snw_node_aop$PathwayID, remove_duplicates)
snw_node_aop_valid <- select(snw_node_aop,Ensembl, fromPublication,fromWikiPathways,fromDisGeNET,gLayCluster,snpID,CNVassociated,PathwayID)
#Getting relevant columns for network construction
snw_node_aop_valid <- separate_rows(snw_node_aop_valid,PathwayID,sep=", ")
#Separating PathwayID rows to have one or multiple PathwayIDs per gene; one PathwayID per row
sparqlquery("WikiPathways","pathwaymap.txt","pathwaymap")
#Querying WikiPathways for all Pathway IDs and Pathway titles for mapping
pathwaymap$PathwayTitle <- sub("@en$","",pathwaymap$PathwayTitle)
pathwaymap$PathwayTitle <- gsub('"','',pathwaymap$PathwayTitle)
#Cleaning up mapping file by removing quotation marks and "@en" appendix of all rows
snw_node_aop_valid <- merge(snw_node_aop_valid,pathwaymap,by="PathwayID",all.x=TRUE)
#Adding PathwayTitle to the df to map pathway IDs to titles
snw_node_aop_valid[is.na(snw_node_aop_valid)] <- ""
#Replacing NA with empty for nicer look in Cytoscape
snw_node_aop_valid <- snw_node_aop_valid %>%
rename(Ensembl_source = Ensembl,
PathwayID_target = PathwayID)
#Renaming source and target cols for import
snw_node_aop_valid$Ensembl <- snw_node_aop_valid$Ensembl_source
snw_node_aop_valid$PathwayID <- snw_node_aop_valid$PathwayID_target
#Duplicating source and target cols for import
snw_node_aop_valid <- snw_node_aop_valid[,c("Ensembl_source","Ensembl","fromPublication","fromDisGeNET","fromWikiPathways","gLayCluster","snpID","CNVassociated","PathwayID_target","PathwayID","PathwayTitle")]
#Reordering columns
snw_node_aop_valid <- lapply(snw_node_aop_valid, function(x) gsub("NA","",x))
#At some point during processing, literal 'NA' is added to the df which is incorrectly interpreted during Cytoscape import
#We simply replace all occurrences of 'NA' with an empty string
write.table(snw_node_aop_valid, file=paste0(other_savepath,"AOP-Wiki/snw_node_aop.tsv"), sep="\t", quote=FALSE, row.names=FALSE)
#Writing to file for Cytoscape import
commandsRun(sprintf('network import file columnTypeList=s,sa,sa,sa,sa,sa,sa,sa,t,ta,ta delimiters=\\t file=%s firstRowAsColumnNames=true rootNetworkList=-- Create new network collection -- startLoadRow=1',paste0(other_savepath,"AOP-Wiki/snw_node_aop.tsv")))
#Importing network to Cytoscape
Sys.sleep(1)
renameNetwork("Genes from AOP network with SNW attributes")
snw_node_aop_valid_node <- getTableColumns("node")
#Reading node table as R object
snw_node_aop_valid_node <- snw_node_aop_valid_node %>%
rowwise() %>%
mutate(label=paste(na.omit(c_across(all_of(c("PathwayTitle")))), collapse=""))
#Adding 'label' column for pathway nodes in preparation for merge with gene-AOP network
snw_node_aop_valid_node <- snw_node_aop_valid_node %>%
rowwise() %>%
mutate(type = case_when(
str_detect(PathwayID, "\\S") ~ "Pathway",
str_detect(Ensembl, "\\S") ~ "gene",
TRUE ~ NA_character_
))
#Adding 'type' column in preparation for merge with gene-AOP network
loadTableData(snw_node_aop_valid_node,data.key.column='name',table.key.column = 'name',table='node')
#Loading modified node table back to network
snw_node_aop_cluster <- select(snw_node_aop, Ensembl, CNVassociated, gLayCluster, GO_Pvals,GO_Terms,N_nodes,Nodes,Publication_source,DisGeNET_source,WikiPathways_source,WikiPathways_CNV,WikiPathways_noCNV)
#Getting relevant columns for gene-cluster associations
summary_terms <- read.delim(file=paste0(getwd(),"/Data/summary_go_terms.txt"),sep="\t",header=TRUE,quote="")
#Loading summary GO terms
snw_node_aop_cluster <- merge(snw_node_aop_cluster,summary_terms,by="gLayCluster")
#Adding summary terms per cluster
snw_node_aop_cluster[is.na(snw_node_aop_cluster)] <- ""
#Replacing NA with empty for nicer look in Cytoscape
snw_node_aop_cluster <- snw_node_aop_cluster %>%
rename(Ensembl_source = Ensembl,
gLayCluster_target = gLayCluster)
#Renaming source and target columns for import
snw_node_aop_cluster$Ensembl <- snw_node_aop_cluster$Ensembl_source
snw_node_aop_cluster$gLayCluster <- snw_node_aop_cluster$gLayCluster
#Duplicating source and target columns for import
snw_node_aop_cluster <- select(snw_node_aop_cluster, Ensembl,Ensembl_source, CNVassociated, gLayCluster,gLayCluster_target,N_nodes,Publication_source,DisGeNET_source,WikiPathways_source,WikiPathways_CNV,WikiPathways_noCNV,summary_term)
snw_node_aop_cluster <- snw_node_aop_cluster[,c("Ensembl_source","Ensembl","CNVassociated","gLayCluster_target","gLayCluster","N_nodes","Publication_source","DisGeNET_source","WikiPathways_source","WikiPathways_CNV","WikiPathways_noCNV","summary_term")]
#Reordering columns
write.table(snw_node_aop_cluster, file=paste0(other_savepath,"AOP-Wiki/snw_node_aop_cluster.tsv"), sep="\t", quote=FALSE, row.names=FALSE)
#Writing to file for Cytoscape import
commandsRun(sprintf('network import file columnTypeList="s,sa,sa,t,ta,ta,ta,ta,ta,ta,ta,ta,ta" delimiters=\\t decimalSeparator="." file=%s firstRowAsColumnNames=true rootNetworkList=-- Create new network collection -- startLoadRow=1',paste0(other_savepath,"AOP-Wiki/snw_node_aop_cluster.tsv")))
#Importing network to Cytoscape
Sys.sleep(1)
renameNetwork("Genes from AOP network with clusters")
snw_node_aop_cluster_node <- getTableColumns("node")
#Reading node table as R object
snw_node_aop_cluster_node <- snw_node_aop_cluster_node %>%
rowwise() %>%
mutate(label=paste(na.omit(c_across(all_of(c("summary_term")))), collapse=""))
#Adding 'label' column for pathway nodes in preparation for merge with gene-AOP network
snw_node_aop_cluster_node <- snw_node_aop_cluster_node %>%
rowwise() %>%
mutate(type = case_when(
str_detect(gLayCluster, "\\S") ~ "Cluster",
str_detect(Ensembl, "\\S") ~ "gene",
TRUE ~ NA_character_
))
#Adding 'type' column in preparation for merge with gene-AOP network
loadTableData(snw_node_aop_cluster_node,data.key.column='name',table.key.column = 'name',table='node')
#Loading modified node table back to network
altmergeNetworks(sources=c("Genes from AOP network with clusters","Genes from AOP network with SNW attributes"),
title="Genes from AOP network with pathways and clusters",
operation="union",
nodeKeys=c("name","name"))
altmergeNetworks(sources=c("gene-KE-AOP-AO merged network_all","Genes from AOP network with pathways and clusters"),
title="gene-KE-AOP-AO merged network with pathways",
operation="union",
nodeKeys=c("Ensembl","name"))
#Merging gene-KE-AOP-AO network with gene-pathway network
deleteTableColumn("shared.name")
lapply(c("Genes from AOP network with SNW attributes","Genes from AOP network with clusters","Genes from AOP network with pathways and clusters"),deleteNetwork)
#Deleting intermediary networks used to generate full gene-KE-AOP-AO network
genenames <- getTableColumns("node",c("SUID","label","type")) %>%
filter(grepl("gene",type)) %>%
#First selecting gene labels to avoid removing semicolons that should occur in other node labels
mutate(label = str_replace(label, ";",""))
#Removing ";" from gene names caused by Cytoscape merging
#Row values are merged if they are the same and are separated by semicolons if they are not
#Gene names in the 'label' column are not generated in every network since it is not necessary, but this means that after merging, one row will have an empty string and the other the gene name
#This leads to gene names being preceded by an empty character and a semicolon
loadTableData(genenames,"SUID","node","SUID")
#Loading corrected names back to the network
exportNetwork(filename=paste0(nw_savepath,"gene-KE-AO merged network with pathways"), type="CX", overwriteFile = TRUE)
end_section("Cluster/pathway extension")
## ChEBI EXTENSION --------------------------------------------------------------------------------------------------------------------------------
start_section("ChEBI extension")
getlinkset <- function(url,dest) {
if (!file.exists(dest)) {
dir.create(dest)
}
file <- "chembl_23_hsa_20180126.zip"
curl_download(url, destfile=file.path(dest,file))
unzip(zipfile=file.path(dest,file),exdir=dest)
}
#Setting up directory creation, file download and unzip for chembl linkset from CyTargetLinker website
linkset_url <- "https://ndownloader.figshare.com/files/21623691?private_link=6cf358aaaaf5adeecce9"
linkset_dir <- paste0(getwd(),"/Data/CyTargetLinker")
if (!file.exists(file.path(linkset_dir, "chembl_23_hsa_20180126.xgmml"))) {
getlinkset(linkset_url,linkset_dir)
print("Linkset downloaded and unzipped.")
file.remove(paste0(getwd(),"/Data/CyTargetLinker/chembl_23_hsa_20180126.zip"))
#Deleting the zip file after extracting the desired xgmml file from it
} else {
print("Linkset already exists.")
}
#Downloading and unzipping if necessary
chembl_path <- paste0(getwd(),"/Data/CyTargetLinker/chembl_23_hsa_20180126.xgmml")
#Defining path to chembl linkset for easy access
commandsRun(sprintf('cytargetlinker extend direction=SOURCES idAttribute=Ensembl  linkSetFiles=%s network=current',chembl_path))
#Extending the pathway-gene-AOP network with chemicals from the linkset
mapped_chembls <- getTableColumns("node","CTL.ChEMBL")
mapped_chembls <- na.omit(mapped_chembls)
#Getting mapped chemicals and removing NA from df for further processing
# metabolitedb_dir <- paste0(getwd(),"/BridgeDb/metabolites_20240416.bridge")
# getmetabolitemap <- function(dir = metabolitedb_dir, confirmation = "Metabolite BridgeDb mapping file not detected. Download metabolite BridgeDb mapping file (2.65 GB)? (yes/no): ") {
#   if(file.exists(dir)) {
#     message("File already present at ", dir, " No files downloaded.")
#   } else {
#     confirm <- readline(prompt = confirmation)
#     if (tolower(confirm) == "yes") {
#       bridgedb_hs <- getDatabase("Homo sapiens",location=paste0(getwd(),"/BridgeDb"))
#       message("BridgeDb mapping file downloaded to ",dir)
#     } else {
#       message("File download cancelled.")
#     }
#   }
# }
# getmetabolitemap()
metabolite_bridge_dir <- paste0(getwd(),"/BridgeDb/metabolites_20240416.bridge")
metabolite_mapper <- loadDatabase(metabolite_bridge_dir)
metabolite_input <- data.frame(
source = rep("Cl", length(mapped_chembls[, 1])),
identifier = mapped_chembls[, 1]
)
#Making a new df to be used as input for bridgedb
chembl_map <- maps(metabolite_mapper,metabolite_input,"Ce")
#Mapping from ChEMBL to ChEBI
chembl_map <- chembl_map %>%
select(identifier,mapping) %>%
filter(grepl("CHEBI", mapping, fixed=TRUE)) %>%
rename(ChEMBLid = identifier,
ChEBIid = mapping)
chebimap <- read.delim(paste0(getwd(),"/Data/CyTargetLinker/chebimap.tsv"), sep = "\t")
#Loading .tsv containing ChEBI IDs with associated ontology IDs and names
chebimap <- chebimap %>%
rename(ChEBIid = chemical,
ChEBIrole = role,
ChEBIrolename = rolename) %>%
#Renaming cols
mutate(ChEBIid = str_replace(ChEBIid, ".*/",""),
ChEBIrole = str_replace(ChEBIrole, ".*/","")) %>%
#Removing URL to get ChEBI IDs
mutate(ChEBIid = str_replace(ChEBIid, "_",":"),
ChEBIrole = str_replace(ChEBIrole,"_",":"))
#Replacing underscores with colons
chembl_chebi <- merge(chembl_map, chebimap, by="ChEBIid",all.x=TRUE)
#Mapping ChEBI ontology terms to ChEBI IDs available from network mapping
chembl_chebi <- chembl_chebi %>%
group_by(ChEBIid,ChEMBLid) %>%
summarise(ChEBIrole = paste(ChEBIrole, collapse = "; "),
ChEBIrolename = paste(ChEBIrolename, collapse = "; "))
chembl_chebi <- chembl_chebi %>%
mutate_all(~str_replace_all(.,"NA",""))
#Replacing literal 'NA' with empty string
chembl_map <- read.delim(paste0(getwd(),"/Data/chembl_name.tsv"),sep="\t")
#Loading a file containing ChEMBL IDs mapped to compound names retrieved through the WikiData SPARQL endpoint
chembl_chebi <- merge(chembl_chebi, chembl_map, by = "ChEMBLid",all=TRUE)
#Adding compound names to the df
chembl_chebi$type <- "ChEBI node"
chembl_chebi$label <- chembl_chebi$compound_name
#Adding type and label attributes for visualisation
loadTableData(chembl_chebi, data.key.column = "ChEMBLid", "node",table.key.column = "CTL.ChEMBL")
#loading data back to network
chebi_node <- getTableColumns("node",c("SUID","CTL.ChEMBL","ChEBIid"))
#Getting SUID, ChEMBL, and ChEBI columns of all nodes to filter
chemblnochebi <- chebi_node %>%
filter(!is.na(CTL.ChEMBL) & is.na(ChEBIid))
#Filtering for nodes that have a ChEMBL ID but no ChEBI ID
#Desired to remove all CTL-added nodes that couldn't be mapped to a ChEBI ID
selectNodes(nodes = chemblnochebi$SUID, by.col = "SUID")
#Selecting these nodes in Cytoscape
deleteSelectedNodes()
#Deleting selected nodes
#This process could also be done by using Cytoscape filters (createcolumnFilter), but is much slower
#Removing ChEMBL nodes added by CyTargetLinker that do not have ChEBI IDs
deleteTableColumn("CTL.ChEMBL")
renameNetwork("gene-KE-AOP network with pathways and chemicals")
exportNetwork(filename=paste0(nw_savepath,"gene-AOP merged network with pathways and chemicals"), type="CX", overwriteFile = TRUE)
end_section("ChEBI extension")
createVisualStyle("AOP_vis")
setVisualStyle("AOP_vis")
#Creating and setting a new visual style for the AOP network
setNodeLabelMapping(
table.column="label",
style.name="AOP_vis"
)
#Setting node labels using dedicated node label column
setNodeColorMapping(
table.column = "type",
mapping.type="d",
table.column.values = c("AO","AOP","KE","gene","Pathway","Cluster","ChEBI node"),
colors=c("#FB6a4A","#FEB24C","#FA9FB5","#74C476","#1DEFF2","#b48fff","#bfcdf5"),
style.name="AOP_vis"
)
#Setting node colors using dedicated type column
createColumnFilter(
filter.name = "KE-MIE",
column = "KEisMIEin",
criterion = "h",
predicate = "CONTAINS",
anyMatch = TRUE,
apply = TRUE
)
#Selecting which KEs are tagged as MIEs
kemienode <- getSelectedNodes()
setNodeBorderColorBypass(
node.names = kemienode,
new.colors = "#3030f0"
)
setNodeBorderWidthBypass(
node.names = kemienode,
new.sizes = 20
)
setNodeShapeDefault(
new.shape="ROUND_RECTANGLE",
style.name="AOP_vis"
)
setNodeFontSizeDefault (
new.size = "25",
style.name = "AOP_vis"
)
setEdgeSourceArrowShapeDefault(
new.shape = "DELTA",
style.name="AOP_vis"
)
setEdgeColorDefault(
new.color="#BCBCBC",
style.name="AOP_vis"
)
setEdgeColorMapping(
table.column = "isMIEedge",
table.column.values = c(0,1),
colors = c("#BCBCBC", "#3030f0"),
style.name= "AOP_vis"
)
setEdgeLineWidthMapping(
table.column = "isMIEedge",
table.column.values = c(0,1),
widths = c(1,3),
style.name = "AOP_vis"
)
commandsRun('analyzer analyze directed=true selectedOnly=false')
#Running analyzer for topoligcal information
setNodeSizeMapping(
table.column = "Indegree",
sizes=c(50,250),
mapping.type='c',
style.name="AOP_vis"
)
#Setting node size relative to indegree (in this graph: edges going from bottom to top)
setNodeHeightMapping(
table.column="name",
table.column.values = NULL,
heights = c(0,100),
mapping.type ="d",
style.name="AOP_vis"
)
fitContent()
start_section("ChEBI role subsetting")
rolecount <- chembl_chebi$ChEBIrolename %>%
strsplit("; ") %>%
unlist() %>%
data.frame(role = .) %>%
group_by(role) %>%
summarize(count = n()) %>%
arrange(desc(count))
#Counting how frequently which ChEBI roles can be mapped to a chemical in the network
#Can be used to select roles of interest based on frequency\
#write.table(rolecount, "C:/users/klemm/Desktop/rolecount-all.tsv",sep="\t",quote=FALSE,row.names=FALSE)
filter_chebi <- function(keyword) {
chems <- chembl_chebi %>%
separate_rows(ChEBIrolename, sep = "; ") %>%
filter(grepl(paste0("\\b(", paste(keyword, collapse = "|"), ")\\b"),ChEBIrolename)) %>%
pull(ChEBIid) %>%
as.list() %>%
selectNodes( ,by.col="ChEBIid")
chems_list <- chems$nodes
#Defining a simple function to filter ChEBI nodes by associated role name
#Getting nodes matching the given ChEBI role
chems_genes <- selectFirstNeighbors(direction="outgoing")
#Getting first neighbors of ChEBI nodes, which will be gene nodes
clearSelection()
genes <- setdiff(chems_genes$nodes, chems$nodes)
#Getting the SUIDs of the gene nodes associated with a given ChEBI role
#Done by getting the intersection between ChEBI nodes and the selection of both ChEBI and gene nodes
#This is because gene nodes are selected as being first neighbors, so the set of selected nodes will contain both the ChEBI and gene nodes
selectNodes(genes)
#Selecting gene nodes associated with given ChEBI role
genes_pws <- selectFirstNeighbors(direction="outgoing")
#Getting outgoing first neighbors of gene nodes which are pathway and cluster nodes
pws <- setdiff(genes_pws$nodes,genes)
#Again getting the intersection of gene and pathway/cluster nodes due to neighbor selection including both the source and neighbor nodes
clearSelection()
selectNodes(genes)
allngbrs <- selectFirstNeighbors(direction="incoming")
#Selecting incoming first neighbors of gene nodes
#This will select all chemical nodes rather than the chemical nodes with the relevant ChEBI role
suidtype <- getTableColumns("node",columns=c("SUID","type"))
kengbrs <- setdiff(allngbrs$nodes, suidtype[suidtype$type == "ChEBI node","SUID"])
#Therefore, KE nodes are filtered out using the 'type' attribute
kengbrs <- setdiff(kengbrs, genes)
#Filtering out gene nodes
if (length(kengbrs) > 0) {
clearSelection()
selectNodes(kengbrs)
aop_kes <- selectFirstNeighbors(direction="incoming")
#Selecting AOP nodes related to KE nodes
aopngbrs <- setdiff(aop_kes$nodes, kengbrs)
#Filtering out KE nodes
clearSelection()
selectNodes(aopngbrs)
aop_aos <- selectFirstNeighbors(direction="incoming")
#Selecting AO nodes related to AOP nodes
aongbrs <- setdiff(aop_aos$nodes, aopngbrs)
clearSelection()
} else {
aongbrs <- c()
aopngbrs <- c()
}
connectednodes <- c(chems_list, genes, pws, kengbrs,aopngbrs, aongbrs)
selectNodes(connectednodes)
createSubnetwork(nodes = connectednodes, subnetwork.name = paste0("Role ", paste(keyword, collapse = ", "), " subnetwork "))
Sys.sleep(0.5)
setCurrentNetwork("gene-KE-AOP network with pathways and chemicals")
setCurrentView("gene-KE-AOP network with pathways and chemicals")
clearSelection()
}
filter_chebi(c("toxin","neurotoxin","genotoxin"))
filter_chebi(c("agrochemical","piscicide","rodenticide","fungicide","herbicide","insecticide","nematicide"))
fitContent()
commandsRun('string stringify colDisplayName=name column=Ensembl compoundQuery=true cutoff=0.9 includeNotMapped=true  networkType="full STRING network" species="Homo sapiens" networkNoGui=current')
