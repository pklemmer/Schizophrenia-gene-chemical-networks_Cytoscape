#Getting which clusters have fewer than 5 nodes associated with them
valid_clustered_nodetable <- read_clustered_nodetable[!read_clustered_nodetable$gLayCluster %in% invalidclusters, ]
#Generating a new df containing only nodes associated with clusters that had 5 or more nodes
split_tbl <- split(valid_clustered_nodetable, valid_clustered_nodetable$gLayCluster)
sourcecount <- function(cluster) {
wpcount <- sum(split_tbl[[cluster]][["WikiPathways"]] == 1, na.rm = TRUE)
dgcount <- sum(split_tbl[[cluster]][["DisGeNET"]] == 1, na.rm = TRUE)
litcount <- sum(split_tbl[[cluster]][["Literature"]] == 1, na.rm = TRUE)
stringcount <- sum(split_tbl[[cluster]][["STRINGnode"]] == 1, na.rm = TRUE)
result_df <- data.frame(
gLayCluster = split_tbl[[cluster]][["gLayCluster"]][1],
WikiPathways_source = wpcount,
DisGeNET_source = dgcount,
Literature_source = litcount,
STRING_source = stringcount
)
}
sources_count <- do.call(rbind, lapply(seq_along(split_tbl),sourcecount))
#For each cluster, counting how many nodes are associated with which sources
## GO ANALYSIS ------------------------------------------------------------------------------------------------------------------------
split_df <- split(valid_clustered_nodetable$Ensembl,valid_clustered_nodetable$gLayCluster)
split_list <- lapply(split_df, as.vector)
#Splitting the node table by cluster number, i.e. lists of Ensembl IDs are created per cluster
go <- function(cluster) {
gost(
query = cluster,
organism = "hsapiens",
ordered_query = FALSE,
multi_query = TRUE,
significant = TRUE,
exclude_iea = FALSE,
measure_underrepresentation = FALSE,
evcodes = FALSE,
user_threshold = 0.05,
correction_method = "g_SCS",
domain_scope ="annotated",
custom_bg = NULL,
numeric_ns = "",
sources = NULL,
as_short_link = FALSE,
highlight = TRUE
)
}
go_list <- lapply(split_list,go)
#Iterating the gost GO function over all clusters
saveRDS(go_list, file=paste0(nw_savepath,"/go_list.rds"))
#Saving the entire generated GO analysis as R object locally
get_top_terms <- function(cluster) {
terms <- toString(go_list[[cluster]][["result"]][["term_name"]][1:5])
#Extracting the top 5 term names associated with each cluster
pval <- toString(go_list[[cluster]][["result"]][["p_values"]][1:5])
#Extracting the p-values for the corresponding top 5 term names
nodes <- paste(go_list[[cluster]][["meta"]][["query_metadata"]][["queries"]][["query_1"]],collapse=",")
nnodes <- str_count(toString(go_list[[cluster]][["meta"]][["query_metadata"]][["queries"]][["query_1"]]),"\\S+")
#Extracing the number of nodes/genes contained in each cluster
result_df <- data.frame(
gLayCluster = cluster,
GO_Terms = terms,
GO_Pvals = pval,
Nodes = nodes,
N_nodes = nnodes
)
}
topterms_df <- do.call(rbind, lapply(names(go_list),get_top_terms))
#Getting top 5 term names and corresponding p-values for each cluster and storing in topterms_df
topterms_df <- cbind(topterms_df,sources_count)
#joining the cluster table and the table detailing the amount of sources per cluster
write.table(topterms_df, file=paste0(getwd(),"/CSVs/GO-clusters-vis.tsv"), sep = "\t",row.names=FALSE,quote=FALSE)
#Writing the table to file for Cytoscape import during visualisation
loadTableData(topterms_df,data.key.column="gLayCluster",table.key.column="gLayCluster")
#Loading the generated top terms and p-values back to the supernetwork; every gene belonging to cluster x is now associated with the top terms of cluster x
renameNetwork(title=paste0(getNetworkName(),"-GO"))
snw_scz_filtered_string_clustered_go <- getNetworkName()
#Renaming and saving the network name to indicate addition of GO information
compare_term_id_lists <- function(list1, list2) {
common_elements <- intersect(list1, list2)
return(length(common_elements))
}
#Defining a function to detect intersections between GO term IDs between 2 clusters
term_matches_matrix <- matrix(NA, nrow = length(go_list), ncol = length(go_list))
#Preparing a matrix to store intersections
for (i in 1:(length(go_list) - 1)) {
for (j in (i + 1):length(go_list)) {
# Access term_id lists for clusters i and j
term_id_i <- go_list[[i]][["result"]][["term_id"]]
term_id_j <- go_list[[j]][["result"]][["term_id"]]
term_matches_matrix[i, j] <- compare_term_id_lists(term_id_i, term_id_j)
}
}
#Iterate through each pair of clusters and compare term_id lists
rownames(term_matches_matrix) <- colnames(term_matches_matrix) <- names(go_list)
#Renaming the matrix rows and columns to match clusters
exportNetwork(filename=paste0(nw_savepath,"SCZ_SNW_filtered_STRING_clustered_GO"),"CX",network=snw_scz_filtered_string_clustered_go,overwriteFile=TRUE)
#Exporting the filtered, stringified, clustered supernetwork after GO as cx file and tagging it with the time and data to match with the metadata file
##VISUALISATION -----------------------------------------------------------------------------------------------------------------------
commandsRun(sprintf("network import file columnTypeList='s,sa,sa,sa,sa,sa,sa,sa,sa,sa,sa,sa' file=%s firstRowAsColumnNames=true delimiters=\\t rootNetworkList=-- Create new network collection -- startLoadRow=1", paste0(getwd(),"/CSVs/GO-clusters-vis.tsv")))
#Importing the previoulsy generated table 'go_vis_filered' back to Cytoscape as new network
#Essential to use .tsv and importing as such to avoid conflicts generated by .csv - commas separating terms in a string are interpreted as different columns by Cytoscape
renameNetwork("GO_Visualisation_SCZ_SNW")
loadTableData(
data = read.table(file=paste0(getwd(),"/CSVs/summary_go_terms.txt"),header=TRUE, sep ="\t"),
data.key.column = "gLayCluster",
table.key.column = "gLayCluster"
)
#Loading an additional column into the network containing manually created summaries of GO terms based on biological knowledge
setVisualStyle("default")
layoutNetwork("force-directed")
#Applying a basic visual style and layout to the network
setNodeSizeMapping(
table.column = "N_nodes",
sizes = c(50,200),
mapping.type = "c"
)
#Setting the node size proportional to the number of nodes making up a cluster, e.g. a cluster containing more nodes is bigger
setNodeCustomPieChart(
columns = c("DisGeNET_source","Literature_source","WikiPathways_source","STRING_source"),
colors = paletteColorBrewerAccent(value.count = 8)
)
#Turning nodes into pie charts showing which sources make up the proportions of the nodes in them
setNodeFillOpacityDefault(
new.opacity = 0
)
#Removing node background
setNodeLabelMapping(
table.column = "summary_term"
)
#Changing node label to the processes/terms the nodes represent
setNodeLabelPositionDefault(
new.nodeAnchor = "S",
new.graphicAnchor = "S",
new.justification = "c",
new.xOffset = "0",
new.yOffset = "30"
)
#Moving label
layoutNetwork("cose")
#Adding network layout
View(term_matches_matrix)
?write.table
write.table(term_matches_matrix, file = "C:/Users/klemm/Desktop/termmatch.csv",sep = ",")
write.table(term_matches_matrix, file = "C:/Users/klemm/Desktop/termmatch.csv",sep = ",", row.names = true, col.names = true)
write.table(term_matches_matrix, file = "C:/Users/klemm/Desktop/termmatch.csv",sep = ",", row.names = TRUE, col.names = TRUE)
write.table(term_matches_matrix, file = "C:/Users/klemm/Desktop/termmatch.csv",sep = ",", row.names = TRUE, col.names = TRUE)
trans_term <- t(term_matches_matrix)
write.table(trans_term, file = "C:/Users/klemm/Desktop/transtermmatch.csv",sep = ",", row.names = TRUE, col.names = TRUE)
install.packages("reshape2")
library(reshape2)
term_matches_df <- as.data.frame(term_matches_matrix)
# Melt the data frame to the desired format
melted_df <- melt(term_matches_df)
# Rename the columns
colnames(melted_df) <- c("Cluster1", "Cluster2", "Matches")
View(melted_df)
term_matches_df <- as.data.frame(term_matches_matrix)
# Melt the data frame to the desired format
melted_df <- melt(term_matches_df)
# Extract cluster names
cluster_names <- rownames(term_matches_matrix)
# Initialize a data frame to store the results
result_df <- data.frame(Cluster1 = character(),
Cluster2 = character(),
Matches = numeric(),
stringsAsFactors = FALSE)
# Populate the result data frame
for (cluster1 in cluster_names) {
for (cluster2 in cluster_names) {
if (cluster1 != cluster2) {
matches <- melted_df[melted_df$Cluster1 == cluster1 & melted_df$Cluster2 == cluster2, "value"]
result_df <- rbind(result_df, data.frame(Cluster1 = cluster1,
Cluster2 = cluster2,
Matches = sum(matches, na.rm = TRUE)))
}
}
}
# Display the result
print(result_df)
View(result_df)
compare_term_id_lists <- function(list1, list2) {
common_elements <- intersect(list1, list2)
return(length(common_elements))
}
# Assuming go_list is the list you have
# Initialize a data frame to store the results
result_df <- data.frame(Cluster1 = character(),
Cluster2 = character(),
Matches = numeric(),
stringsAsFactors = FALSE)
# Populate the result data frame
for (i in 1:(length(go_list) - 1)) {
for (j in (i + 1):length(go_list)) {
term_id_i <- go_list[[i]][["result"]][["term_id"]]
term_id_j <- go_list[[j]][["result"]][["term_id"]]
matches <- compare_term_id_lists(term_id_i, term_id_j)
result_df <- rbind(result_df, data.frame(Cluster1 = names(go_list)[i],
Cluster2 = names(go_list)[j],
Matches = matches))
}
}
# Display the result
print(result_df)
This code should now correctly calculate the number of matches in the third column based on the original go_list. Adjust the code as needed to fit your data structure.
compare_term_id_lists <- function(list1, list2) {
common_elements <- intersect(list1, list2)
return(length(common_elements))
}
#Setting up a function to get intersections between cluster term IDs
match_df <- data.frame(source = character(),
target = character(),
Matches = numeric(),
stringsAsFactors = FALSE)
#Setting up a df to store output in
for (i in 1:(length(go_list) - 1)) {
for (j in (i + 1):length(go_list)) {
term_id_i <- go_list[[i]][["result"]][["term_id"]]
term_id_j <- go_list[[j]][["result"]][["term_id"]]
matches <- compare_term_id_lists(term_id_i, term_id_j)
result_df <- rbind(result_df, data.frame(source = names(go_list)[i],
target = names(go_list)[j],
Matches = matches))
#Iterating over go_list to compare GO term IDs between every cluster and store number of overlaps
}
}
View(result_df)
compare_term_id_lists <- function(list1, list2) {
common_elements <- intersect(list1, list2)
return(length(common_elements))
}
#Setting up a function to get intersections between cluster term IDs
match_df <- data.frame(Cluster1 = character(),
Cluster2 = character(),
Matches = numeric(),
stringsAsFactors = FALSE)
#Setting up a df to store output in
for (i in 1:(length(go_list) - 1)) {
for (j in (i + 1):length(go_list)) {
term_id_i <- go_list[[i]][["result"]][["term_id"]]
term_id_j <- go_list[[j]][["result"]][["term_id"]]
matches <- compare_term_id_lists(term_id_i, term_id_j)
result_df <- rbind(result_df, data.frame(Cluster1 = names(go_list)[i],
Cluster2 = names(go_list)[j],
Matches = matches))
#Iterating over go_list to compare GO term IDs between every cluster and store number of overlaps
}
}
compare_term_id_lists <- function(list1, list2) {
common_elements <- intersect(list1, list2)
return(length(common_elements))
}
#Setting up a function to get intersections between cluster term IDs
match_df <- data.frame(Cluster1 = character(),
Cluster2 = character(),
Matches = numeric(),
stringsAsFactors = FALSE)
#Setting up a df to store output in
for (i in 1:(length(go_list) - 1)) {
for (j in (i + 1):length(go_list)) {
term_id_i <- go_list[[i]][["result"]][["term_id"]]
term_id_j <- go_list[[j]][["result"]][["term_id"]]
matches <- compare_term_id_lists(term_id_i, term_id_j)
match_df <- rbind(match_df, data.frame(Cluster1 = names(go_list)[i],
Cluster2 = names(go_list)[j],
Matches = matches))
#Iterating over go_list to compare GO term IDs between every cluster and store number of overlaps
}
}
View(match_df)
colnames(match_df) <- c("source","target","GO_term_matches")
View(match_df)
?loadTableData
#Loading an additional column into the network containing manually created summaries of GO terms based on biological knowledge
loadTableData(
data = match_df,
data.key.column = "source",
table = "edge",
table.key.column = "source"
)
#Loading an additional column into the network containing manually created summaries of GO terms based on biological knowledge
loadTableData(
data = match_df,
data.key.column = "source",
table = "edge",
table.key.column = "name"
)
View(match_df)
write.table(match_df, file="C:/Users/klemm/Desktop/match_df.csv",sep=",")
write.table(match_df, file="C:/Users/klemm/Desktop/match_df.csv",sep=",", row.names=FALSE)
write.table(match_df, file="C:/Users/klemm/Desktop/match_df.csv",sep=",", row.names=TRUE)
names(match_df)
index(match_df)
rownames(match_df)
#Loading an additional column into the network containing manually created summaries of GO terms based on biological knowledge
commandsRun(sprintf('table set values columnName=keycol handleEquations=false rowList=all table="GO_Visualisation_SCZ_SNW default edge" value=%s', row_names(match_df)))
#Loading an additional column into the network containing manually created summaries of GO terms based on biological knowledge
commandsRun(sprintf('table set values columnName=keycol handleEquations=false rowList=all table="GO_Visualisation_SCZ_SNW default edge" value=%s', rownames(match_df)))
#Loading an additional column into the network containing manually created summaries of GO terms based on biological knowledge
commandsRun(sprintf('table set values columnName=keycol handleEquations=false rowList=all table="GO_Visualisation_SCZ_SNW default edge" value=%s', as.string(rownames(match_df))))
#Loading an additional column into the network containing manually created summaries of GO terms based on biological knowledge
commandsRun(sprintf('table set values columnName=keycol handleEquations=false rowList=all table="GO_Visualisation_SCZ_SNW default edge" value=%s', toString(rownames(match_df))))
##VISUALISATION -----------------------------------------------------------------------------------------------------------------------
commandsRun(sprintf("network import file columnTypeList='s,sa,sa,sa,sa,sa,sa,sa,sa,sa,sa,sa' file=%s firstRowAsColumnNames=true delimiters=\\t rootNetworkList=-- Create new network collection -- startLoadRow=1", paste0(getwd(),"/CSVs/GO-clusters-vis.tsv")))
#Importing the previoulsy generated table 'go_vis_filered' back to Cytoscape as new network
#Essential to use .tsv and importing as such to avoid conflicts generated by .csv - commas separating terms in a string are interpreted as different columns by Cytoscape
renameNetwork("GO_Visualisation_SCZ_SNW")
loadTableData(
data = read.table(file=paste0(getwd(),"/CSVs/summary_go_terms.txt"),header=TRUE, sep ="\t"),
data.key.column = "gLayCluster",
table.key.column = "gLayCluster"
)
?importNetworkFromFile
#Loading an additional column into the network containing manually created summaries of GO terms based on biological knowledge
importNetworkFromFile(file=match_df)
#Renaming columns
write.table(match_df, file=paste0(getwd(),"/CSVs/match_df.tsv"), sep = "\t",row.names=FALSE,quote=FALSE)
#Loading an additional column into the network containing manually created summaries of GO terms based on biological knowledge
importNetworkFromFile(file=paste0(getwd(),"/CSVs/match_df.tsv"))
#Loading an additional column into the network containing manually created summaries of GO terms based on biological knowledge
commandsRun(sprintf("network import file columnTypeList='s,t,sa' file=%s firstRowAsColumNames=true delimiters=\\t startLoadRow=1", paste0(getwd(),"/CSVs/match_df.tsv")))
#Loading an additional column into the network containing manually created summaries of GO terms based on biological knowledge
commandsRun(sprintf("network import file columnTypeList='s,t,sa' file=%s firstRowAsColumnNames=true delimiters=\\t startLoadRow=1", paste0(getwd(),"/CSVs/match_df.tsv")))
##VISUALISATION -----------------------------------------------------------------------------------------------------------------------
commandsRun(sprintf("network import file columnTypeList='s,sa,sa,sa,sa,sa,sa,sa,sa,sa,sa,sa' file=%s firstRowAsColumnNames=true delimiters=\\t rootNetworkList=-- Create new network collection -- startLoadRow=1", paste0(getwd(),"/CSVs/GO-clusters-vis.tsv")))
#Importing the previoulsy generated table 'go_vis_filered' back to Cytoscape as new network
#Essential to use .tsv and importing as such to avoid conflicts generated by .csv - commas separating terms in a string are interpreted as different columns by Cytoscape
renameNetwork("GO_Visualisation_SCZ_SNW")
loadTableData(
data = read.table(file=paste0(getwd(),"/CSVs/summary_go_terms.txt"),header=TRUE, sep ="\t"),
data.key.column = "gLayCluster",
table.key.column = "gLayCluster"
)
#Loading an additional column into the network containing manually created summaries of GO terms based on biological knowledge
commandsRun(sprintf("network import file columnTypeList='s,t,sa' file=%s firstRowAsColumnNames=true delimiters=\\t startLoadRow=1", paste0(getwd(),"/CSVs/match_df.tsv")))
##VISUALISATION -----------------------------------------------------------------------------------------------------------------------
commandsRun(sprintf("network import file columnTypeList='s,sa,sa,sa,sa,sa,sa,sa,sa,sa,sa,sa' file=%s firstRowAsColumnNames=true delimiters=\\t rootNetworkList=-- Create new network collection -- startLoadRow=1", paste0(getwd(),"/CSVs/GO-clusters-vis.tsv")))
#Importing the previoulsy generated table 'go_vis_filered' back to Cytoscape as new network
#Essential to use .tsv and importing as such to avoid conflicts generated by .csv - commas separating terms in a string are interpreted as different columns by Cytoscape
renameNetwork("GO_Visualisation_SCZ_SNW")
loadTableData(
data = read.table(file=paste0(getwd(),"/CSVs/summary_go_terms.txt"),header=TRUE, sep ="\t"),
data.key.column = "gLayCluster",
table.key.column = "gLayCluster"
)
##VISUALISATION -----------------------------------------------------------------------------------------------------------------------
commandsRun(sprintf("network import file columnTypeList='s,sa,sa,sa,sa,sa,sa,sa,sa,sa,sa,sa' file=%s firstRowAsColumnNames=true delimiters=\\t rootNetworkList=-- Create new network collection -- startLoadRow=1", paste0(getwd(),"/CSVs/GO-clusters-vis.tsv")))
#Importing the previoulsy generated table 'go_vis_filered' back to Cytoscape as new network
#Essential to use .tsv and importing as such to avoid conflicts generated by .csv - commas separating terms in a string are interpreted as different columns by Cytoscape
renameNetwork("GO_Visualisation_SCZ_SNW")
loadTableData(
data = read.table(file=paste0(getwd(),"/CSVs/summary_go_terms.txt"),header=TRUE, sep ="\t"),
data.key.column = "gLayCluster",
table.key.column = "gLayCluster"
)
#Loading an additional column into the network containing manually created summaries of GO terms based on biological knowledge
commandsRun(sprintf("network import file columnTypeList='s,t,ea' file=%s firstRowAsColumnNames=true delimiters=\\t startLoadRow=1", paste0(getwd(),"/CSVs/match_df.tsv")))
setVisualStyle("default")
layoutNetwork("force-directed")
#Applying a basic visual style and layout to the network
setNodeSizeMapping(
table.column = "N_nodes",
sizes = c(50,200),
mapping.type = "c"
)
#Setting the node size proportional to the number of nodes making up a cluster, e.g. a cluster containing more nodes is bigger
setNodeCustomPieChart(
columns = c("DisGeNET_source","Literature_source","WikiPathways_source","STRING_source"),
colors = paletteColorBrewerAccent(value.count = 8)
)
#Turning nodes into pie charts showing which sources make up the proportions of the nodes in them
setNodeFillOpacityDefault(
new.opacity = 0
)
#Removing node background
setNodeLabelMapping(
table.column = "summary_term"
)
#Changing node label to the processes/terms the nodes represent
setNodeLabelPositionDefault(
new.nodeAnchor = "S",
new.graphicAnchor = "S",
new.justification = "c",
new.xOffset = "0",
new.yOffset = "30"
)
#Moving label
layoutNetwork("cose")
#Moving label
layoutNetwork("force-directed")
getLayoutNames()
#Moving label
layoutNetwork("degree-circle")
##VISUALISATION -----------------------------------------------------------------------------------------------------------------------
commandsRun(sprintf("network import file columnTypeList='s,sa,sa,sa,sa,sa,sa,sa,sa,sa,sa,sa' file=%s firstRowAsColumnNames=true delimiters=\\t rootNetworkList=-- Create new network collection -- startLoadRow=1", paste0(getwd(),"/CSVs/GO-clusters-vis.tsv")))
#Importing the previoulsy generated table 'go_vis_filered' back to Cytoscape as new network
#Essential to use .tsv and importing as such to avoid conflicts generated by .csv - commas separating terms in a string are interpreted as different columns by Cytoscape
renameNetwork("GO_Visualisation_SCZ_SNW")
loadTableData(
data = read.table(file=paste0(getwd(),"/CSVs/summary_go_terms.txt"),header=TRUE, sep ="\t"),
data.key.column = "gLayCluster",
table.key.column = "gLayCluster"
)
#Loading an additional column into the network containing manually created summaries of GO terms based on biological knowledge
commandsRun(sprintf("network import file columnTypeList='s,t,ea' file=%s firstRowAsColumnNames=true delimiters=\\t startLoadRow=1", paste0(getwd(),"/CSVs/match_df.tsv")))
setVisualStyle("default")
layoutNetwork("force-directed")
#Applying a basic visual style and layout to the network
setNodeSizeMapping(
table.column = "N_nodes",
sizes = c(50,200),
mapping.type = "c"
)
#Setting the node size proportional to the number of nodes making up a cluster, e.g. a cluster containing more nodes is bigger
setNodeCustomPieChart(
columns = c("DisGeNET_source","Literature_source","WikiPathways_source","STRING_source"),
colors = paletteColorBrewerAccent(value.count = 8)
)
#Turning nodes into pie charts showing which sources make up the proportions of the nodes in them
setNodeFillOpacityDefault(
new.opacity = 0
)
#Removing node background
setNodeLabelMapping(
table.column = "summary_term"
)
#Changing node label to the processes/terms the nodes represent
setNodeLabelPositionDefault(
new.nodeAnchor = "S",
new.graphicAnchor = "S",
new.justification = "c",
new.xOffset = "0",
new.yOffset = "30"
)
#Moving label
layoutNetwork("degree-circle")
##VISUALISATION -----------------------------------------------------------------------------------------------------------------------
commandsRun(sprintf("network import file columnTypeList='s,sa,sa,sa,sa,sa,sa,sa,sa,sa,sa,sa' file=%s firstRowAsColumnNames=true delimiters=\\t rootNetworkList=-- Create new network collection -- startLoadRow=1", paste0(getwd(),"/CSVs/GO-clusters-vis.tsv")))
#Importing the previoulsy generated table 'go_vis_filered' back to Cytoscape as new network
#Essential to use .tsv and importing as such to avoid conflicts generated by .csv - commas separating terms in a string are interpreted as different columns by Cytoscape
renameNetwork("GO_Visualisation_SCZ_SNW")
loadTableData(
data = read.table(file=paste0(getwd(),"/CSVs/summary_go_terms.txt"),header=TRUE, sep ="\t"),
data.key.column = "gLayCluster",
table.key.column = "gLayCluster"
)
#Loading an additional column into the network containing manually created summaries of GO terms based on biological knowledge
commandsRun(sprintf("network import file columnTypeList='s,t,ea' file=%s firstRowAsColumnNames=true delimiters=\\t startLoadRow=1", paste0(getwd(),"/CSVs/match_df.tsv")))
setVisualStyle("default")
layoutNetwork("force-directed")
#Applying a basic visual style and layout to the network
setNodeSizeMapping(
table.column = "N_nodes",
sizes = c(50,200),
mapping.type = "c"
)
#Setting the node size proportional to the number of nodes making up a cluster, e.g. a cluster containing more nodes is bigger
setNodeCustomPieChart(
columns = c("DisGeNET_source","Literature_source","WikiPathways_source","STRING_source"),
colors = paletteColorBrewerAccent(value.count = 8)
)
#Turning nodes into pie charts showing which sources make up the proportions of the nodes in them
setNodeFillOpacityDefault(
new.opacity = 0
)
#Removing node background
setNodeLabelMapping(
table.column = "summary_term"
)
#Changing node label to the processes/terms the nodes represent
setNodeLabelPositionDefault(
new.nodeAnchor = "S",
new.graphicAnchor = "S",
new.justification = "c",
new.xOffset = "0",
new.yOffset = "30"
)
#Moving label
layoutNetwork("force-directed")
#Moving label
layoutNetwork("force-directed")
getLayoutNames()
#Moving label
layoutNetwork("cose")
#Moving label
layoutNetwork("isom")
#Moving label
layoutNetwork("hierarchical")
#Moving label
layoutNetwork("kamada-kawai")
#Moving label
layoutNetwork("degree-circle")
#Moving label
setEdgeLineWidthMapping(
column = "GO_term_matches",
mapping.type = "c"
)
#Moving label
setEdgeLineWidthMapping(
table.column = "GO_term_matches",
mapping.type = "c"
)
?setEdgeLineWidthMapping
#Moving label
setEdgeLineWidthMapping(
table.column = "GO_term_matches",
table.column.values = c(0,861),
widths = c(0,50)
mapping.type = "c"
#Moving label
setEdgeLineWidthMapping(
table.column = "GO_term_matches",
table.column.values = c(0,861),
widths = c(0,50),
mapping.type = "c"
)
