write.table(keensgpairs_byensg, file=keensgpairs_byensg_save,quote=FALSE, sep="\t", row.names=FALSE)
#Saving df containing gene-KE-AO-AOP associations to file as tsv for Cytoscape import
commandsRun(sprintf('table import file dataTypeTargetforNetworkCollection="Node Table Columns" delimiters=\\t file=%s firstRowAsColumnNames=true keyColumnForMapping="Ensembl" keyColumnIndex=1 startLoadRow=1',keensgpairs_byensg_save))
#Importing the gene-KE-AO-AOP table to Cytoscape as table add AOP-Wiki info as node attributes
renameNetwork(paste0(getNetworkName(),"_AOP"))
scz_snw_string_go_aop <- getNetworkName()
commandsRun(sprintf('table export options=CSV outputFile=%s table="SCZ_SNW_STRING_clustered_GO_AOP default  node"',paste0(nw_savepath,"SCZ_SNW_STRING_GO_AOP default node")))
#Exporting the network table
scz_snw_string_go_aop_node <- read.csv(file=paste0(nw_savepath,"SCZ_SNW_STRING_GO_AOP default node.csv"),header=TRUE)
#Reading the exported table as Cytoscape object
aop_associated_genes <- scz_snw_string_go_aop_node[!(scz_snw_string_go_aop_node$KEid == ""), , drop=FALSE]
#Getting which rows (=gene nodes) have info from AOP-Wiki associated to them
objects <- c(keensgpairs,separate_keensgpairs,keensgpairs_byensg,keensgpairs_byensg_save,scz_snw_string_go_aop_node,aop_associated_genes)
object_names <- paste0(seq_along(objects),'_')
for (i in n(object_names)) {
assign(paste0(object_names[i],tag),list(keensgpairs,separate_keensgpairs,keensgpairs_byensg)[[i]],envir=.GlobalEnv)
}
result_names <- paste(object_names,tag)
}
aopprocess("AO_KE_Ensembl_query.txt","selected")
commandsRun('table delete column column="gLayCluster.2" table="SCZ_SNW_STRING_clustered_GO default node')
createColumnFilter(
filter.name = "has_GO_result",
column = "N_nodes",
criterion = 0,
predicate = "GREATER_THAN",
anyMatch = TRUE,
apply = TRUE
)
#Selecting nodes included in a 'valid' cluster, i.e. clusters with 5 or more nodes (GO analysis only performed for these)
#N_nodes is only generated for 'valid' clusters, so good column to filter by
invertNodeSelection()
deleteSelectedNodes()
aopprocess <- function(input,tag) {
sparqlquery("AOP-Wiki",input,"keensgpairs")
#Querying AOP-Wiki for a list of all KEs and associated genes. KEs must be contained in an AOP that has an AO from a list of selected AOs
for (i in 1:ncol(keensgpairs)) {
for (j in 1:nrow(keensgpairs)) {
keensgpairs[j, i] <- gsub('"', '', keensgpairs[j, i])
}
}
#Removing quotation marks from the df
separate_keensgpairs <- separate_rows(keensgpairs,Ensembl,sep="; ")
#Dividing comma-separated Ensembl IDs into distinct rows
keensgpairs_byensg <- separate_keensgpairs %>%
group_by(Ensembl) %>%
summarise(KEid = paste(KEid, collapse="; "),
KEtitle = paste(KEtitle, collapse="; "),
AOid = paste(AOid, collapse="; "),
AOtitle = paste(AOtitle, collapse = "; "),
AOPid = paste(AOPid, collapse="; "),
AOPtitle =paste(AOPtitle, collapse="; "))
#Concateinating other variables based on unique Ensembl ID to get list of associated KEs, AOs, and AOPs per gene
keensgpairs_byensg_save <- paste0(getwd(),sprintf("/Data/AOP-Wiki/keensgpairs_byensg_%s.tsv",tag))
#Defining savepath for newly generated df
write.table(keensgpairs_byensg, file=keensgpairs_byensg_save,quote=FALSE, sep="\t", row.names=FALSE)
#Saving df containing gene-KE-AO-AOP associations to file as tsv for Cytoscape import
commandsRun(sprintf('table import file dataTypeTargetforNetworkCollection="Node Table Columns" delimiters=\\t file=%s firstRowAsColumnNames=true keyColumnForMapping="Ensembl" keyColumnIndex=1 startLoadRow=1',keensgpairs_byensg_save))
#Importing the gene-KE-AO-AOP table to Cytoscape as table add AOP-Wiki info as node attributes
renameNetwork(paste0(getNetworkName(),"_AOP"))
scz_snw_string_go_aop <- getNetworkName()
commandsRun(sprintf('table export options=CSV outputFile=%s table="SCZ_SNW_STRING_clustered_GO_AOP default  node"',paste0(nw_savepath,"SCZ_SNW_STRING_GO_AOP default node")))
#Exporting the network table
scz_snw_string_go_aop_node <- read.csv(file=paste0(nw_savepath,"SCZ_SNW_STRING_GO_AOP default node.csv"),header=TRUE)
#Reading the exported table as Cytoscape object
aop_associated_genes <- scz_snw_string_go_aop_node[!(scz_snw_string_go_aop_node$KEid == ""), , drop=FALSE]
#Getting which rows (=gene nodes) have info from AOP-Wiki associated to them
objects <- c(keensgpairs,separate_keensgpairs,keensgpairs_byensg,keensgpairs_byensg_save,scz_snw_string_go_aop_node,aop_associated_genes)
object_names <- paste0(seq_along(objects),'_')
for (i in 1:length(object_names)) {
assign(paste0(object_names[i],tag),list(keensgpairs,separate_keensgpairs,keensgpairs_byensg)[[i]],envir=.GlobalEnv)
}
result_names <- paste(object_names,tag)
}
aopprocess("AO_KE_Ensembl_query.txt","selected")
commandsRun('table delete column column="gLayCluster.2" table="SCZ_SNW_STRING_clustered_GO default node')
createColumnFilter(
filter.name = "has_GO_result",
column = "N_nodes",
criterion = 0,
predicate = "GREATER_THAN",
anyMatch = TRUE,
apply = TRUE
)
#Selecting nodes included in a 'valid' cluster, i.e. clusters with 5 or more nodes (GO analysis only performed for these)
#N_nodes is only generated for 'valid' clusters, so good column to filter by
invertNodeSelection()
deleteSelectedNodes()
aopprocess <- function(input,tag) {
sparqlquery("AOP-Wiki",input,"keensgpairs")
#Querying AOP-Wiki for a list of all KEs and associated genes. KEs must be contained in an AOP that has an AO from a list of selected AOs
for (i in 1:ncol(keensgpairs)) {
for (j in 1:nrow(keensgpairs)) {
keensgpairs[j, i] <- gsub('"', '', keensgpairs[j, i])
}
}
#Removing quotation marks from the df
separate_keensgpairs <- separate_rows(keensgpairs,Ensembl,sep="; ")
#Dividing comma-separated Ensembl IDs into distinct rows
keensgpairs_byensg <- separate_keensgpairs %>%
group_by(Ensembl) %>%
summarise(KEid = paste(KEid, collapse="; "),
KEtitle = paste(KEtitle, collapse="; "),
AOid = paste(AOid, collapse="; "),
AOtitle = paste(AOtitle, collapse = "; "),
AOPid = paste(AOPid, collapse="; "),
AOPtitle =paste(AOPtitle, collapse="; "))
#Concateinating other variables based on unique Ensembl ID to get list of associated KEs, AOs, and AOPs per gene
keensgpairs_byensg_save <- paste0(getwd(),sprintf("/Data/AOP-Wiki/keensgpairs_byensg_%s.tsv",tag))
#Defining savepath for newly generated df
write.table(keensgpairs_byensg, file=keensgpairs_byensg_save,quote=FALSE, sep="\t", row.names=FALSE)
#Saving df containing gene-KE-AO-AOP associations to file as tsv for Cytoscape import
commandsRun(sprintf('table import file dataTypeTargetforNetworkCollection="Node Table Columns" delimiters=\\t file=%s firstRowAsColumnNames=true keyColumnForMapping="Ensembl" keyColumnIndex=1 startLoadRow=1',keensgpairs_byensg_save))
#Importing the gene-KE-AO-AOP table to Cytoscape as table add AOP-Wiki info as node attributes
renameNetwork(paste0(getNetworkName(),"_AOP"))
scz_snw_string_go_aop <- getNetworkName()
commandsRun(sprintf('table export options=CSV outputFile=%s table="SCZ_SNW_STRING_clustered_GO_AOP default  node"',paste0(nw_savepath,"SCZ_SNW_STRING_GO_AOP default node")))
#Exporting the network table
scz_snw_string_go_aop_node <- read.csv(file=paste0(nw_savepath,"SCZ_SNW_STRING_GO_AOP default node.csv"),header=TRUE)
#Reading the exported table as Cytoscape object
aop_associated_genes <- scz_snw_string_go_aop_node[!(scz_snw_string_go_aop_node$KEid == ""), , drop=FALSE]
#Getting which rows (=gene nodes) have info from AOP-Wiki associated to them
objects <- c(keensgpairs,separate_keensgpairs,keensgpairs_byensg,keensgpairs_byensg_save,scz_snw_string_go_aop_node,aop_associated_genes)
object_names <- paste0(objects,'_')
for (i in 1:length(object_names)) {
assign(paste0(object_names[i],tag),list(objects)[[i]],envir=.GlobalEnv)
}
result_names <- paste(object_names,tag)
}
aopprocess("AO_KE_Ensembl_query.txt","selected")
View(`c("https://identifiers.org/aop.events/1841", "https://identifiers.org/aop.events/188", "https://identifiers.org/aop.events/896", "https://identifiers.org/aop.events/402", "https://identifiers.org/aop.events/341", "https://identifiers.org/aop.events/756", "https://identifiers.org/aop.events/425", "https://identifiers.org/aop.events/1512", "https://identifiers.org/aop.events/1739", "https://identifiers.org/aop.events/959", "https://identifiers.org/aop.events/1538", "https://identifiers.org/aop.events/385",
"https://identifiers.org/aop.events/177", "https://identifiers.org/aop.events/889", "https://identifiers.org/aop.events/616", "https://identifiers.org/aop.events/1262", "https://identifiers.org/aop.events/1488", "https://identifiers.org/aop.events/195", "https://identifiers.org/aop.events/2024", "https://identifiers.org/aop.events/757", "https://identifiers.org/aop.events/1656", "https://identifiers.org/aop.events/1968", "https://identifiers.org/aop.events/186", "https://identifiers.org/aop.events/1115",
"https://identifiers.org/aop.events/1846", "https://identifiers.org/aop.events/850", "https://identifiers.org/aop.events/1974", "https://identifiers.org/aop.events/875", "https://identifiers.org/aop.events/890", "https://identifiers.org/aop.events/958", "https://identifiers.org/aop.events/1825", "https://identifiers.org/aop.events/1510", "https://identifiers.org/aop.events/1508", "https://identifiers.org/aop.events/1392", "https://identifiers.org/aop.events/1487", "https://identifiers.org/aop.events/55",
"https://identifiers.org/aop.events/851", "https://identifiers.org/aop.events/381", "https://identifiers.org/aop.events/1492", "https://identifiers.org/aop.events/887", "https://identifiers.org/aop.events/888", "https://identifiers.org/aop.events/1391", "https://identifiers.org/aop.events/682", "https://identifiers.org/aop.events/352", "https://identifiers.org/aop.events/667", "https://identifiers.org/aop.events/1983", "https://identifiers.org/aop.events/383", "https://identifiers.org/aop.events/2146",
"https://identifiers.org/aop.events/201", "https://identifiers.org/aop.events/1869", "https://identifiers.org/aop.events/1969", "https://identifiers.org/aop.events/1602", "https://identifiers.org/aop.events/280", "https://identifiers.org/aop.events/960", "https://identifiers.org/aop.events/1686", "https://identifiers.org/aop.events/1339", "https://identifiers.org/aop.events/1493", "https://identifiers.org/aop.events/279", "https://identifiers.org/aop.events/1502", "https://identifiers.org/aop.events/18",
"https://identifiers.org/aop.events/424", "https://identifiers.org/aop.events/382", "https://identifiers.org/aop.events/192", "https://identifiers.org/aop.events/1738", "https://identifiers.org/aop.events/122", "https://identifiers.org/aop.events/618", "https://identifiers.org/aop.events/961", "https://identifiers.org/aop.events/957", "https://identifiers.org/aop.events/277", "https://identifiers.org/aop.events/52", "https://identifiers.org/aop.events/1635", "https://identifiers.org/aop.events/1513",
"https://identifiers.org/aop.events/1503", "https://identifiers.org/aop.events/281", "https://identifiers.org/aop.events/1875", "https://identifiers.org/aop.events/386", "https://identifiers.org/aop.events/2097", "https://identifiers.org/aop.events/758")_selected`)
keensgpairs
as.character(keensgpairs)
deparse(substitute(keensgpairs))
commandsRun('table delete column column="gLayCluster.2" table="SCZ_SNW_STRING_clustered_GO default node')
createColumnFilter(
filter.name = "has_GO_result",
column = "N_nodes",
criterion = 0,
predicate = "GREATER_THAN",
anyMatch = TRUE,
apply = TRUE
)
#Selecting nodes included in a 'valid' cluster, i.e. clusters with 5 or more nodes (GO analysis only performed for these)
#N_nodes is only generated for 'valid' clusters, so good column to filter by
invertNodeSelection()
deleteSelectedNodes()
aopprocess <- function(input,tag) {
sparqlquery("AOP-Wiki",input,"keensgpairs")
#Querying AOP-Wiki for a list of all KEs and associated genes. KEs must be contained in an AOP that has an AO from a list of selected AOs
for (i in 1:ncol(keensgpairs)) {
for (j in 1:nrow(keensgpairs)) {
keensgpairs[j, i] <- gsub('"', '', keensgpairs[j, i])
}
}
#Removing quotation marks from the df
separate_keensgpairs <- separate_rows(keensgpairs,Ensembl,sep="; ")
#Dividing comma-separated Ensembl IDs into distinct rows
keensgpairs_byensg <- separate_keensgpairs %>%
group_by(Ensembl) %>%
summarise(KEid = paste(KEid, collapse="; "),
KEtitle = paste(KEtitle, collapse="; "),
AOid = paste(AOid, collapse="; "),
AOtitle = paste(AOtitle, collapse = "; "),
AOPid = paste(AOPid, collapse="; "),
AOPtitle =paste(AOPtitle, collapse="; "))
#Concateinating other variables based on unique Ensembl ID to get list of associated KEs, AOs, and AOPs per gene
keensgpairs_byensg_save <- paste0(getwd(),sprintf("/Data/AOP-Wiki/keensgpairs_byensg_%s.tsv",tag))
#Defining savepath for newly generated df
write.table(keensgpairs_byensg, file=keensgpairs_byensg_save,quote=FALSE, sep="\t", row.names=FALSE)
#Saving df containing gene-KE-AO-AOP associations to file as tsv for Cytoscape import
commandsRun(sprintf('table import file dataTypeTargetforNetworkCollection="Node Table Columns" delimiters=\\t file=%s firstRowAsColumnNames=true keyColumnForMapping="Ensembl" keyColumnIndex=1 startLoadRow=1',keensgpairs_byensg_save))
#Importing the gene-KE-AO-AOP table to Cytoscape as table add AOP-Wiki info as node attributes
renameNetwork(paste0(getNetworkName(),"_AOP"))
scz_snw_string_go_aop <- getNetworkName()
commandsRun(sprintf('table export options=CSV outputFile=%s table="SCZ_SNW_STRING_clustered_GO_AOP default  node"',paste0(nw_savepath,"SCZ_SNW_STRING_GO_AOP default node")))
#Exporting the network table
scz_snw_string_go_aop_node <- read.csv(file=paste0(nw_savepath,"SCZ_SNW_STRING_GO_AOP default node.csv"),header=TRUE)
#Reading the exported table as Cytoscape object
aop_associated_genes <- scz_snw_string_go_aop_node[!(scz_snw_string_go_aop_node$KEid == ""), , drop=FALSE]
#Getting which rows (=gene nodes) have info from AOP-Wiki associated to them
objects <- c(keensgpairs,separate_keensgpairs,keensgpairs_byensg,keensgpairs_byensg_save,scz_snw_string_go_aop_node,aop_associated_genes)
object_names <- paste0(deparse(substitute(objects)),'_')
for (i in 1:length(object_names)) {
assign(paste0(object_names[i],tag),list(objects)[[i]],envir=.GlobalEnv)
}
result_names <- paste(object_names,tag)
}
aopprocess("AO_KE_Ensembl_query.txt","selected")
View(`c("https://identifiers.org/aop.events/1841", "https://identifiers.org/aop.events/188", "https://identifiers.org/aop.events/896", "https://identifiers.org/aop.events/402", "https://identifiers.org/aop.events/341", "https://identifiers.org/aop.events/756", "https://identifiers.org/aop.events/425", "https://identifiers.org/aop.events/1512", "https://identifiers.org/aop.events/1739", "https://identifiers.org/aop.events/959", "https://identifiers.org/aop.events/1538", "https://identifiers.org/aop.events/385",
"https://identifiers.org/aop.events/177", "https://identifiers.org/aop.events/889", "https://identifiers.org/aop.events/616", "https://identifiers.org/aop.events/1262", "https://identifiers.org/aop.events/1488", "https://identifiers.org/aop.events/195", "https://identifiers.org/aop.events/2024", "https://identifiers.org/aop.events/757", "https://identifiers.org/aop.events/1656", "https://identifiers.org/aop.events/1968", "https://identifiers.org/aop.events/186", "https://identifiers.org/aop.events/1115",
"https://identifiers.org/aop.events/1846", "https://identifiers.org/aop.events/850", "https://identifiers.org/aop.events/1974", "https://identifiers.org/aop.events/875", "https://identifiers.org/aop.events/890", "https://identifiers.org/aop.events/958", "https://identifiers.org/aop.events/1825", "https://identifiers.org/aop.events/1510", "https://identifiers.org/aop.events/1508", "https://identifiers.org/aop.events/1392", "https://identifiers.org/aop.events/1487", "https://identifiers.org/aop.events/55",
"https://identifiers.org/aop.events/851", "https://identifiers.org/aop.events/381", "https://identifiers.org/aop.events/1492", "https://identifiers.org/aop.events/887", "https://identifiers.org/aop.events/888", "https://identifiers.org/aop.events/1391", "https://identifiers.org/aop.events/682", "https://identifiers.org/aop.events/352", "https://identifiers.org/aop.events/667", "https://identifiers.org/aop.events/1983", "https://identifiers.org/aop.events/383", "https://identifiers.org/aop.events/2146",
"https://identifiers.org/aop.events/201", "https://identifiers.org/aop.events/1869", "https://identifiers.org/aop.events/1969", "https://identifiers.org/aop.events/1602", "https://identifiers.org/aop.events/280", "https://identifiers.org/aop.events/960", "https://identifiers.org/aop.events/1686", "https://identifiers.org/aop.events/1339", "https://identifiers.org/aop.events/1493", "https://identifiers.org/aop.events/279", "https://identifiers.org/aop.events/1502", "https://identifiers.org/aop.events/18",
"https://identifiers.org/aop.events/424", "https://identifiers.org/aop.events/382", "https://identifiers.org/aop.events/192", "https://identifiers.org/aop.events/1738", "https://identifiers.org/aop.events/122", "https://identifiers.org/aop.events/618", "https://identifiers.org/aop.events/961", "https://identifiers.org/aop.events/957", "https://identifiers.org/aop.events/277", "https://identifiers.org/aop.events/52", "https://identifiers.org/aop.events/1635", "https://identifiers.org/aop.events/1513",
"https://identifiers.org/aop.events/1503", "https://identifiers.org/aop.events/281", "https://identifiers.org/aop.events/1875", "https://identifiers.org/aop.events/386", "https://identifiers.org/aop.events/2097", "https://identifiers.org/aop.events/758")_selected`)
i <- 1
while (i <= 10) {
print(3 *i)
if(i%%8) {
print(i)
break
}
else {print(3 *i)}
}
i <- 1
while (i <= 10) {
print(3 *i)
if(i%%8) {
print(i)
break
}
else {}
}
i <- 1
while (i <= 10) {
print(3 *i) }
i <- 1
while (i <= 10) {
print(3 *i)
if (! i %% 8) {
i+1}
else {break}
}
i <- 1
while (i <= 10) {
print(3 *i)
if !( i %% 8) {
i <- 1
while (i <= 10) {
print(3 *i)
if (i %% 8) {
i <-  i+1}
else {break}
}
i <- 1
while (i <= 10) {
print(3 *i)
if (!i %% 8) {
i <-  i+1}
else {break}
}
i <- 1
while (i <= 10) {
print(3 *i)
if ((i %% 8) == 0) {
i <-  i+1}
else {break}
}
i <- 1
while (i <= 10) {
print(3 *i)
if ((i %% 8) == 0) {
i <-  i+1}
print(i) }
setwd("~/GitHub/SCZ-CNV")
#Setting working directory
rm(list=ls())
#Cleaning up workspace
packages <- c("dplyr","httr","stringr","gprofiler2","rvest","tidyr")
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
install.packages(packages[!installed_packages])
}
if(!"rWikiPathways" %in% installed.packages()){
if (!requireNamespace("BiocManager", quietly=TRUE))
install.packages("BiocManager")
BiocManager::install("rWikiPathways")
}
if(!"RCy3" %in% installed.packages()){
if (!requireNamespace("BiocManager", quietly=TRUE))
install.packages("BiocManager")
BiocManager::install("RCy3")
}
#Checking if required packages are installed and installing if not
#Different structure for rWikiPathways and RCy3 packages as these are not installed directly but via the BiocManager package
invisible(lapply(c(packages,"rWikiPathways","RCy3"), require, character.only = TRUE))
#Loading libraries
sysdatetime <- Sys.time()
datetime <- format(sysdatetime, format = "%Y-%m-%d_%Hh%M")
dir.create("Outputs")
dir.create(sprintf("Outputs/Session-%s",datetime))
dir.create(sprintf("Outputs/Session-%s/Networks",datetime))
#Creating directories for outputs generated by this script to be saved in; new "Session" folder created each time the script is ran (contains generated networks, metadata, and sessionInfo)
nw_savepath <- sprintf("%1$s/Outputs/Session-%2$s/Networks/",getwd(),datetime)
file.create(sprintf("Outputs/Session-%s/metadata.txt",datetime))
#Creating a new metadata file with the current date and time as suffix for easier organisation
#Such a metadata file should be generated every time this script is ran to record parameters and versions of functions or databases, including the time avoids files being overwritten if the script is run multiple times a day (can even include seconds if script is ran multiple times per minute)
metadata.add <- function(info) {
write(sapply(info, as.character), sprintf("Outputs/Session-%s/metadata.txt",datetime),append=TRUE, sep = "\n")
}
metadata.add(sysdatetime)
metadata.add(Sys.timezone())
metadata.add("")
#Adding the timezone, date, and time to the metadata
invisible(file.create(sprintf("Outputs/Session-%s/sessioninfo-%s.txt",datetime,datetime)))
writeLines(capture.output(sessionInfo()),sprintf("Outputs/Session-%s/sessioninfo-%s.txt",datetime,datetime))
#Generating and adding a sessionInfo file to the current session output folder
execution_times <- list()
start_section <- function(section_name) {
execution_times[[section_name]] <<- Sys.time()
}
end_section <- function(section_name) {
end_time <- Sys.time()
start_time <- execution_times[[section_name]]
execution_time <- end_time - start_time
# Convert elapsed time to seconds
execution_time_seconds <- as.numeric(execution_time, units = "secs")
# Convert seconds to a human-readable format with two decimal places
time_string <- format(round(execution_time_seconds, 2), nsmall = 2)
# Add "s" for seconds
time_string <- paste(time_string, "s", sep = "")
measurements <- paste(section_name, "\t", time_string, "\n", sep = "")
cat(measurements, file = sprintf("Outputs/Session-%s/execution-times.txt",datetime), append = TRUE)
# Remove start time from the list
execution_times[[section_name]] <- NULL
}
cytoscapePing()
cytoscapeVersionInfo()
#Checking if Cytoscape is running and version info
metadata.add(capture.output(cytoscapeVersionInfo()))
checkinstall.app <- function(app) {
status_string <- getAppStatus(app)
#Getting install status of app
words <- strsplit(status_string, " ")[[1]]
last_word <- tail(words, 1)
#getAppStatus returns a character string instead of a logical value, so the last word (usually either "Installed" or "Uninstalled") from the output is checked
if (last_word == "Installed") {
print(sprintf("App %s is already installed.",app))
} else {
installApp(app)
print(sprintf("Installed app %s.",app))
}
}
#Function to check whether required Cytoscape apps are installed and installing them if not
applist <- c("Wikipathways", "DisGeNET-app", "CyTargetLinker","stringApp","BridgeDb","clusterMaker2")
#WikiPathways v.3.3.10
#DisGeNET-app v.7.3.0
#CyTargetLinker v. 4.1.0
#stringApp v. 2.0.2
#BridgeDb v.1.2.0
#clusterMaker2 v.2.3.4
lapply(applist,checkinstall.app)
#Checking and installing (if required) necessary Cytoscape apps
lapply(applist,getAppInformation)
metadata.add("Required Cytoscape apps and versions:")
invisible(metadata.add(print(lapply(applist,getAppInformation))))
metadata.add("")
# FUNCTION DICTIONARY-------------------------------------------------------------------------------------------------------------------
.defaultBaseUrl <- 'http://127.0.0.1:1234/v1'
#Defining the default base URL found in the RCy3 source as R object for altmergeNetworks
altmergeNetworks <- function(               sources = NULL,
title = NULL,
operation = "union",
nodeKeys = NULL,
nodeMergeMap = NULL,
nodesOnly = FALSE,
edgeKeys = NULL,
edgeMergeMap = NULL,
networkMergeMap = NULL,
inNetworkMerge = TRUE,
base.url = .defaultBaseUrl) {
cmd.string <- 'network merge' # a good start
# sources must be suppled
if(is.null(sources)) {
message("Missing sources!")
return(NULL)
} else {
sources.str <- paste(sources, collapse = ",")
cmd.string <- paste0(cmd.string,' sources="',sources.str,'"')
}
# defaults
cmd.string <- paste0(cmd.string,' operation=',operation)
cmd.string <- paste0(cmd.string,' nodesOnly=',nodesOnly)
cmd.string <- paste0(cmd.string,' inNetworkMerge=',inNetworkMerge)
# optional args
if(!is.null(title))
cmd.string <- paste0(cmd.string,' netName="',title,'"')
if(!is.null(nodeKeys))
cmd.string <- paste0(cmd.string,' nodeKeys="',paste(nodeKeys, collapse = ","),'"')
if(!is.null(edgeKeys))
cmd.string <- paste0(cmd.string,' edgeKeys="',paste(edgeKeys, collapse = ","),'"')
if(!is.null(nodeMergeMap)){
nodeMergeMap.str <- paste(nodeMergeMap, collapse = ",")
nodeMergeMap.str <- gsub("c\\(", "{", nodeMergeMap.str)
nodeMergeMap.str <- gsub("\\)", "}", nodeMergeMap.str)
cmd.string <- paste0(cmd.string,' nodeMergeMap="',nodeMergeMap.str,'"')
}
if(!is.null(edgeMergeMap)){
edgeMergeMap.str <- paste(edgeMergeMap, collapse = ",")
edgeMergeMap.str <- gsub("c\\(", "{", edgeMergeMap.str)
edgeMergeMap.str <- gsub("\\)", "}", edgeMergeMap.str)
cmd.string <- paste0(cmd.string,' edgeMergeMap="',edgeMergeMap.str,'"')
}
if(!is.null(networkMergeMap)){
networkMergeMap.str <- paste(networkMergeMap, collapse = ",")
networkMergeMap.str <- gsub("c\\(", "{", networkMergeMap.str)
networkMergeMap.str <- gsub("\\)", "}", networkMergeMap.str)
cmd.string <- paste0(cmd.string,' networkMergeMap="',networkMergeMap.str,'"')
}
res.data <- commandsPOST(cmd.string, base.url = base.url)
if(!is.null(res.data$SUID))
return(res.data$SUID)
else
return(res.data)
}
#Normally, RCy3's 'mergeNetworks' function would be used to unify imported networks into one supernetwork
#This function does however not work on the latest RCy3 release (v.2.22.1), but does work when running the script on RCy3 v.2.14.2
#RCy3 2.14.2 requires R v.4.1.3, requiring the entire script to run on an old version of R for one function that is used once
#Here, we redefine the function using the source code from RCy3 v.2.14.2 and simply use this alternate function to merge networks
sparqlquery <- function(endpoint,queryfile,output) {
if (tolower(endpoint) %in% c("WikiPathways","wikipathways","wp","WP")) {
file_path <- paste0(getwd(),sprintf("/Data/WikiPathways/%s",queryfile))
#Specifying file path to the .txt file containing the query
base_url <- "https://sparql.wikipathways.org/sparql/?default-graph-uri=&query="
#Defining the base URL preceding all SPARQL URLs for the endpoint
} else if (tolower(endpoint) %in% c("AOP-Wiki", "aopwiki","aop-wiki","AOPWiki")) {
file_path <- paste0(getwd(),sprintf("/Data/AOP-Wiki/%s",queryfile))
#Specifying file path to the .txt file containing the query
base_url <- "https://aopwiki.rdf.bigcat-bioinformatics.org/sparql/?default-graph-uri=&query="
#Defining the base URL preceding all SPARQL URLs for the endpoint
} else {
print("Error: Please specify either WikiPathways or AOP-Wiki as endpoint.")
}
querybody <- paste(readLines(file_path), collapse = "")
#Reading a text file containing a SPARQL query stored in the repo
encoded_query <- URLencode(querybody)
#Encoding the query as URL
full_url <- paste0(base_url, encoded_query, "&format=text/html&timeout=0&signal_void=on")
#Joining the query from the text file and the base URL and adding that output is desired as HTML
html <- read_html(full_url)
#Sending the query to the SPARQL endpoint and extracting as HTML
tablebody <- html %>%
html_element("body") %>%
html_element("div") %>%
html_element("table")
#Navigating to the table output by the SPARQL query
assign(output, html_table(tablebody), envir=.GlobalEnv)
#Getting the output as tibble
}
#Function to send a SPARQL query defined in a local text file to the endpoint and extract to desired dataframe
createNodeSource <- function(source,doi=NULL) {
if (source == "WikiPathways") {
networkname <- getNetworkName()
nodetable <- paste0(networkname," default node")
}
#Networks imported from WikiPathways have a type in the node table designations, as they have 2 spaces between "default" and "node" instead of one
#This check determines which node table name format is to be applied depending on the source (WikiPathways or other)
else {
networkname <- getNetworkName()
nodetable <- paste0(networkname," default node")
}
commandsRun(sprintf("table create column columnName=fromWikiPathways table=%s type=string",nodetable))
commandsRun(sprintf("table create column columnName=fromDisGeNET table=%s type=string",nodetable))
commandsRun(sprintf("table create column columnName=fromPublication table=%s type=string",nodetable))
commandsRun(sprintf("table create column columnName=Publication.doi table=%s type=string",nodetable))
commandsRun(sprintf("table create column columnName=fromSTRING table=%s type=string",nodetable))
#Creating a new column for each source used for all networks
if ( source == "STRINGnode") {
commandsRun(sprintf('table set values columnName=%1$s handleEquations=false rowList="selected:true" table=%2$s value=1',source,nodetable))
}
else {
commandsRun(sprintf("table set values columnName=%1$s handleEquations=false rowList=all table=%2$s value=1",source,nodetable))
#Filling the new column of the corresponding source with 1 to indicate which source the node is imported from
}
if (!is.null(doi)) {
commandsRun(sprintf("table set values columnName=Publication.doi handleEquations=false rowList=all table=%1$s value=%2$s",nodetable,doi))
#Adding doi for literature used if provided
}
}
#Function to create new column in node table specifying origin of network/node
disgenetRestUrl<-function(netType,host="127.0.0.1",port=1234,version="v7"){
if(is.null(netType)){
print("Network type not specified.")
}else{
disgeneturl<-sprintf("http://%s:%i/disgenet/%s/%s",host,port,version,netType)
}
return (disgeneturl)
}
net <- "gene-disease-net"
disgenetRestUrl(netType = net)
#Defining object for REST to call DisGeNET automation module; defining that we will be using gene-disease associations (GDA)
disgenetRestCall<-function(netType,netParams){
disgeneturl<-disgenetRestUrl(netType)
restCall<-POST(disgeneturl, body = netParams, encode = "json")
result<-content(restCall,"parsed")
return(result)
}
#Object that executes REST calls to DisGeNET module in Cytoscape
geneDisParams <- function(source,dis,min) {list(
source = source,
assocType = "Any",
diseaseClass = "Any",
diseaseSearch = dis,
geneSearch = " ",
initialScoreValue = min,
finalScoreValue = "1.0"
)}
#Specifying parameters of the GDA network to be imported
#queryspecies.wp <- c("Homo sapiens","Rattus norvegicus","Mus musculus")
#getPathways.wp <- function(i) {
#pw <- findPathwaysByText(i)
#pw <- pw %>%
#dplyr::filter(species %in% queryspecies.wp)
#Filtering by species
# pw.ids <- paste0(i, "_wpids")
