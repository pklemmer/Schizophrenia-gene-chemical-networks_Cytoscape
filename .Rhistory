##SETUP -------------------------------------------------------------------------------------------------------------------------------------------------
#Setting working directory to documents folder in which the file is located
setwd("~")
#Installing and loading packages needed for this script
packages <- c("tm","dplyr","ggplot2","stringr","DT")
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
install.packages(packages[!installed_packages])
}
library("tm")
library("ggplot2")
library("dplyr")
library("stringr")
library("DT")
#Reading comment file as R object; file is tab-separated, which is specified in read.delim
raw_df <- read.delim("Crawler Comments.txt", sep = "\t")
##SETUP -------------------------------------------------------------------------------------------------------------------------------------------------
#Setting working directory to documents folder in which the file is located
setwd("~")
#Installing and loading packages needed for this script
packages <- c("tm","dplyr","ggplot2","stringr","DT")
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
install.packages(packages[!installed_packages])
}
library("tm")
library("ggplot2")
library("dplyr")
library("stringr")
library("DT")
#Reading comment file as R object; file is tab-separated, which is specified in read.delim
raw_df <- read.delim("Crawler Comments.txt", sep = "\t")
## FUNCTIONS -------------------------------------------------------------------------------------------------------------------------------------------
#Defining a function to reencode the text in the comments for processing
reencode <- function (col) {
#Encoding from UTF-8 to latin writing
encoded_col <- iconv(col, from = "UTF-8", to = "latin1", sub = "")
#Removing non-printable symbols (emojis, UTF codes etc.)
cleaned_col <- gsub("[^[:print:]]", "", encoded_col)
}
#Specifying which column should be cleaned
#Here: comment text
columns_to_reencode <- c("Text")
#Generating a 'clean' data frame
#Remove the row containing the video description
#Then, remove '@' in front of author names
#Finally, reencode comment text
clean_df <- raw_df %>%
filter(Type == "Comment") %>%
mutate(Author = str_replace(Author, "@", "")) %>%
mutate(across(all_of(columns_to_reencode), ~reencode(.)))
#Counting how frequently a unique value (in this case, author names) are found in the 'Author' column in the file
authorfreq <- table(clean_df$Author)
#Transforming the table to a data frame for easier interpretation
authorfreq <- data.frame(authorfreq)
#Ordering rows by frequency
authorfreq <- authorfreq %>% arrange(desc(Freq))
#Defining a function to plot author frequency in a bar plot
authorfreq_plot <- function(min) {
authorfreq <- authorfreq[authorfreq$Freq >= min, ]
ggplot(authorfreq, aes(x=reorder(Var1,Freq), y = Freq)) +
geom_bar(stat="identity", width= 0.5, fill = "midnightblue")+
labs(x = "Author",y = "Count", title = paste("Comment author by frequency for authors with >=",min," comment(s)"))+
theme(axis.text.x = element_text(angle = 60, vjust = 1.1, hjust = 1, size = 1),
panel.background = element_rect(fill = "white"), # White background
panel.grid.major.y = element_line(color = "grey80",size=0.5),
panel.grid.major.x=element_blank())+ # Thin grey lines for major grid
scale_y_continuous(breaks = seq(0, max(authorfreq$Freq), by = 1))
}
authorfreq_plot(1)
#ggsave('author_1.png',plot=last_plot(), width=10, height=8, dpi=300)
commentsbylikes <- clean_df %>%
arrange(desc(Likes)) %>%
select("Author","Text","Likes","Comment","Date")
#Select the column containing the text of all the comments
comments <- clean_df[,"Text"]
#Merging all comments into one object for counting
all_text <- paste(comments, collapse = " ")
#Forcing lowercase
cleaned_text <- tolower(all_text)
#Splitting the text from all comments into individual words
words <- unlist(strsplit(cleaned_text, "\\s+"))
#Getting a list of 'stop words' from the 'tm' package
#These are common words like "i" "you" "the" etc. that should be filtered out for analyzing word frequency
stop_words <- stopwords("en")
words <- words[!words %in% stop_words]
#Counting how often each word occurrs
word_count <- table(words)
#Converting the table to a data frame for easier viewing
word_count_df <- as.data.frame(word_count, stringsAsFactors = FALSE)
#Setting column names
colnames(word_count_df) <- c("word", "frequency")
#Sorting the data frame by frequency in descending order
word_counts <- word_count_df %>% arrange(desc(frequency))
selectcomments <- function (author = NULL, keyword = NULL) {
if (!is.null(author) & !is.null(keyword)) {
author_rows <- grep(author, clean_df$Author, ignore.case = TRUE)
keyword_pattern <- paste(keyword, collapse = "|")
keyword_rows <- grep(keyword_pattern, clean_df$Text, ignore.case = TRUE)
rows <- intersect(author_rows, keyword_rows)
}
else if (!is.null(author)) {
rows <- grep(author,clean_df$Author, ignore.case=FALSE)
}
else if (!is.null(keyword)) {
keyword_pattern <- paste(keyword, collapse = "|")
rows <- grep(keyword_pattern, clean_df$Text, ignore.case = TRUE)
} else {
print("Error: Please specify either an author, a keyword, or both that should be filtered for.")
}
comments_set <- clean_df[rows,c("Author","Text","Likes","Comment","Date")]
# View(comments_set)
assign("comments_set",comments_set,envir=.GlobalEnv)
}
## USE THIS -----------------------------------------------------------------------------------------------------------
#Open the table that shows how often each author has commented
View(authorfreq)
#Open the table that shows how often each word in all the comments appears
View(word_counts)
#Open the table that shows all comments by number of likes
View(commentsbylikes)
#Generate bar chart to show authors by number of comments left
#Just change the number between the () - if it is 3, the graph will include authors that have left three or more comments
authorfreq_plot(4)
actualite <- c("today","now","nowadays","today's","now's","current","currently")
conflict <- c("Israel","Palestine","israeli","palestinian","hamas","ukraine","ukrainian","russia","russian","putin","Zelenskyy","Tibet","Uyghur","China","chinese")
war <- c("USA","germany","russia","USSR","france","england","great britain","american","german","french","soviet","russian","english","british","U.S.","U.S","united states","nazi","nazism","third reich","reich")
link <- c("grandparent","grandparents","grandfather","grandpa","grandmother","grandma","grandfathers","grandmothers","elders","elder","parent","parents")
semitism <- c("jew","jewish","zion","zionist","semite","semitic","antisemite","antisemitic","israel","israeli","hate")
free <- c("free","liberated","liberation","freed")
memory <- c("commemoration","commemorate","never again","celebrate","remember","record","history")
genocide <- c("srebrenica","armenian","armenia","uyghur","darfour","rwanda","palestine","genocide","genocidal","auschwitz")
covid <- c("covid","covid-19","covid19","coronoa","virus","coronavirus","vaccination","pandemic")
#Select comments by keyword group or author
#Here, selecting comments containing keywords defined in list "actualite" from any author
selectcomments(keyword=actualite, author = NULL )
datatable(comments_set, options = list(autoWidth = TRUE, columnDefs = list(list(
targets = "_all",
render = JS(
"function(data, type, row, meta) {",
"  return type === 'display' && typeof data === 'string' && data.length > 50 ?",
"    '<div style=\"white-space:normal;\">' + data + '</div>' : data;",
"}")
))))
#Cytoscape 3.10.1
setwd("~/GitHub/SCZ-CNV")
#Setting working directory
rm(list=ls(env=.GlobalEnv))
#Cleaning up workspace
packages <- c("dplyr","httr","stringr","gprofiler2","rvest","tidyr","curl")
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
install.packages(packages[!installed_packages])
}
# if(!"rWikiPathways" %in% installed.packages()) {
#   if (!requireNamespace("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
#   BiocManager::install("rWikiPathways")
# }
if(!"RCy3" %in% installed.packages()){
if (!requireNamespace("BiocManager", quietly=TRUE))
install.packages("BiocManager")
BiocManager::install("RCy3")
}
if(!"BridgeDbR" %in% installed.packages()){
if (!requireNamespace("BiocManager", quietly=TRUE))
install.packages("BiocManager")
BiocManager::install("BridgeDbR")
}
#Checking if required packages are installed and installing if not
#Different structure for rWikiPathways and RCy3 packages as these are not installed directly but via the BiocManager package
invisible(lapply(c(packages,"RCy3","BridgeDbR"), require, character.only = TRUE))
#Loading libraries
?setNodeBorderColorMapping
?createColumnFilter
?setNodeBorderWidthMapping
