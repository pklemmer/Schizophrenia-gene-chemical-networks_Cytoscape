renameNetwork("WikiPathways edges")
altmergeNetworks(sources = c("WikiPathways nodes","WikiPathways edges"),
title = "WikiPathways networks",
operation = "union",
nodeKeys=c("WPNodeID","name"))
#Union merging the node and edge networks to extend the node list with corresponding edges
Sys.sleep(0.5)
createNodeSource("fromWikiPathways")
deleteNetwork('WikiPathways nodes')
deleteNetwork('WikiPathways edges')
Sys.sleep(1)
#Pausing the script for 1 second - when letting the script run without this, the publication source creation fails
commandsRun(sprintf("network import file columnTypeList='sa,sa,source,sa,sa,sa,sa' file=%s firstRowAsColumnNames=true rootNetworkList=-- Create new network collection -- startLoadRow=1", paste0(getwd(),"/Data/Publications/Trubetskoy.txt")))
#Importing network from file
#List of 120 genes implicated in Trubetskoy et al., doi: 10.1038/s41586-022-04434-5
commandsRun("table rename column columnName=Ensembl.ID newColumnName=Ensembl table=Trubetskoy.txt default node")
#Renaming the Ensembl.ID column from the dataset to Ensembl for coherence with networks from other sources
commandsRun("table rename column columnName=Index.SNP newColumnName=snpID table=Trubetskoy.txt default node")
createNodeSource("fromPublication","10.1038/s41586-022-04434-5")
#Adding literature as  source to all imported nodes and adding the doi of the corresponding paper
renameNetwork("Trubetskoy risk genes")
#Renaming the newly imported network
metadata.add("Publications")
metadata.add("Trubetskoy et al. doi: 10.1038/s41586-022-04434-5")
metadata.add("")
networklist <- getNetworkList()
setCurrentNetwork(networklist[[1]])
for(i in 1:length(networklist)) {
current <- getNetworkName()
altmergeNetworks(c(current,networklist[[i]]), paste(current,networklist[[i]]),"union",inNetworkMerge = TRUE,nodeKeys=c("Ensembl","Ensembl"))
}
#Looping through the network list to merge all currently open networks with each other, creating one large unified network
renameNetwork("Schizophrenia supernetwork")
networklist <- getNetworkList()
snw_scz <- getNetworkName()
#Getting the name of the unified network to preserve it from deletion
lapply(networklist[networklist != snw_scz],deleteNetwork)
#Deleting all networks besides newly generated unified network
exportNetwork(filename=paste0(nw_savepath,"SCZ_SNW"),"CX", network = snw_scz, overwriteFile=TRUE)
#Exporting the supernetwork as cx file
end_section("Importing and merging")
## STRING --------------------------------------------------------------------------------------------------------------------------
start_section("STRING")
commandsRun('string stringify colDisplayName=name column=Ensembl compoundQuery=true cutoff=0.9 includeNotMapped=true  networkType="full STRING network" species="Homo sapiens" networkNoGui=current')
mapTableColumn("Ensembl","Human","Ensembl","HGNC")
#   #Generating a new column 'HGNC' from Ensembl identifiers - easier and less error-prone than merging various name columns from different import sources
renameTableColumn("HGNC","Name2")
#Renaming the new 'HGNC' column to 'Name2', which is now to be used as default name column. ('shared name' and 'name' columns are immutable and cannot be deleted or renamed)
marked_cols <- as.list(getTableColumnNames()[!(getTableColumnNames() %in% c("selected","name.copy" ,"SUID","shared name","name","fromDisGeNET","fromWikiPathways","Ensembl","fromPublication","Publication.doi","fromSTRING","CNVassociated","PathwayID","NodeID","NodeIDType","snpID","Name2","DisGeNETname"))])
lapply(marked_cols, function(column) {
deleteTableColumn(column=column)
})
#Filtering columns
renameNetwork("SCZ_SNW_STRING")
scz_snw_string <- getNetworkName()
exportNetwork(filename=paste0(nw_savepath,"SCZ_SNW_STRING"),"CX",network=scz_snw_string,overwriteFile=TRUE)
#Exporting the filtered, stringified supernetwork as cx file and tagging it with the time and data to match with the metadata file
end_section("STRING")
## CLUSTERING ----------------------------------------------------------------------------------------------------------------------
start_section("Clustering")
createColumnFilter(filter.name="delete.noensembl", column="Ensembl","ENSG","DOES_NOT_CONTAIN")
deleteSelectedNodes()
#Filtering out nodes that do not have an ENSG Ensembl identifier mapped to them
# marked_cols <- as.list(getTableColumnNames()[!(getTableColumnNames() %in% c("selected","name.copy" ,"SUID","shared name","name","Name2","fromDisGeNET","fromWikiPathways","Ensembl","fromPublication","Publication.doi","fromSTRING","CNVassociated"))])
# lapply(marked_cols, function(column) {
#   deleteTableColumn(column=column)
# })
#Deleting all the columns besides immutable columns, Ensembl, name, and source columns
metadata.add("GLay Clustering")
metadata.add(capture.output(commandsRun('cluster glay clusterAttribute=__glayCluster createGroups=false network=current restoreEdges=true showUI=true undirectedEdges=true')))
#Clustering the network using the GLay community cluster from the clusterMaker Cytoscape app and recording outcome to metadata
renameNetwork("SCZ_SNW_STRING_clustered")
renameTableColumn('__glayCluster','gLayCluster')
#Renaming the newly generated gLayCluster column as the original name with two underscores is not recognized during gene ontology
snw_scz_string_clustered <- getNetworkName()
clustered_nodetable <- paste0(other_savepath,sprintf("/%s node table.csv",snw_scz_string_clustered))
#Saving the file path to the node table for easier reading (note the double space between node and table)
commandsRun(sprintf('table export options=CSV outputFile=%1$s table="%2$s default  node"',clustered_nodetable,snw_scz_string_clustered))
#Exporting the node table as .csv file to the current session's "Network" folder
exportNetwork(filename=paste0(nw_savepath,"SCZ_SNW_STRING_clustered"),"CX",network=snw_scz_string_clustered,overwriteFile=TRUE)
#Exporting the filtered, stringified, clustered supernetwork as cx file and tagging it with the time and data to match with the metadata file
read_clustered_nodetable <- read.csv(clustered_nodetable)
#Reading the exported csv
split_df <- split(read_clustered_nodetable$Ensembl,read_clustered_nodetable$gLayCluster)
#Splitting the node table by cluster
nodecount <- sapply(split_df, length)
#Counting how many nodes are in each cluster
countmatrix <- matrix(seq(1,length(nodecount)), ncol=1)
countmatrix <- cbind(countmatrix,as.numeric(nodecount))
#Construcing a matrix showing how many nodes are in each cluster
invalidclusters <- as.list(countmatrix[countmatrix[, 2] < 5, 1])
#Getting which clusters have fewer than 5 nodes associated with them
valid_clustered_nodetable <- read_clustered_nodetable[!read_clustered_nodetable$gLayCluster %in% invalidclusters, ]
#Generating a new df containing only nodes associated with clusters that had 5 or more nodes
split_tbl <- split(valid_clustered_nodetable, valid_clustered_nodetable$gLayCluster)
# test <- split_tbl[[1]]
# test2 <- test[, c("fromWikiPathways", "fromDisGeNET", "fromPublication")]
# colnames(test2) <- c("fromWikiPathways", "fromDisGeNET", "fromPublication")
#
# column_combinations_3 <- combn(colnames(test2),3,FUN=function(x) paste(x, collapse="_and_"))
# column_combinations_2 <- combn(colnames(test2),2,FUN=function(x) paste(x, collapse="_and_"))
# for (combination in column_combinations_2) {
#   test2[paste(combination,collapse="_and_")] <- test2[[combination[1]]] & test2[[combination[2]]]
# }
# for (combination in column_combinations_3) {
#   test2[paste(combination, collapse = "_")] <- test2[[combination[1]]] & test2[[combination[2]]] & test2[[combination[3]]]
# }
#
sourcecount <- function(cluster) {
wpcount <- sum(split_tbl[[cluster]][["fromWikiPathways"]] == 1, na.rm = TRUE)
dgcount <- sum(split_tbl[[cluster]][["fromDisGeNET"]] == 1, na.rm = TRUE)
litcount <- sum(split_tbl[[cluster]][["fromPublication"]] == 1, na.rm = TRUE)
stringcount <- sum(split_tbl[[cluster]][["fromSTRINGnode"]] == 1, na.rm = TRUE)
result_df <- data.frame(
gLayCluster = split_tbl[[cluster]][["gLayCluster"]][1],
WikiPathways_source = wpcount,
DisGeNET_source = dgcount,
Publication_source = litcount,
STRING_source = stringcount
)
}
sources_count <- do.call(rbind, lapply(seq_along(split_tbl),sourcecount))
#For each cluster, counting how many nodes are associated with which sources
cnvassociatedcount <- function(cluster) {
cnvcount <- sum(split_tbl[[cluster]][["CNVassociated"]] == 1,na.rm=TRUE)
total_wp_nodes <- sources_count[sources_count$gLayCluster == split_tbl[[cluster]][["gLayCluster"]][1], "WikiPathways_source"]
non_cnv_count <- total_wp_nodes - cnvcount
result_df <- data.frame(
gLayCluster = split_tbl[[cluster]][["gLayCluster"]][1],
WikiPathways_CNV = cnvcount,
WikiPathways_noCNV = non_cnv_count
)
}
cnvassociated_count <- do.call(rbind,lapply(seq_along(split_tbl),cnvassociatedcount))
#For each cluster, count how many nodes originally come from CNV-associated pathways which pathways they come from
end_section("Clustering")
## GO ANALYSIS ------------------------------------------------------------------------------------------------------------------------
start_section("GO Analysis")
split_df <- split(valid_clustered_nodetable$Ensembl,valid_clustered_nodetable$gLayCluster)
split_list <- lapply(split_df, as.vector)
#Splitting the node table by cluster number, i.e. lists of Ensembl IDs are created per cluster
go <- function(cluster) {
gost(
query = cluster,
organism = "hsapiens",
ordered_query = FALSE,
multi_query = TRUE,
significant = TRUE,
exclude_iea = FALSE,
measure_underrepresentation = FALSE,
evcodes = FALSE,
user_threshold = 0.05,
correction_method = "g_SCS",
domain_scope ="annotated",
custom_bg = NULL,
numeric_ns = "",
sources = NULL,
as_short_link = FALSE,
highlight = TRUE
)
}
go_list <- lapply(split_list,go)
#Iterating the gost GO function over all clusters
saveRDS(go_list, file=paste0(other_savepath,"/go_list.rds"))
#Saving the entire generated GO analysis as R object locally
get_top_terms <- function(cluster) {
terms <- toString(go_list[[cluster]][["result"]][["term_name"]][1:5])
#Extracting the top 5 term names associated with each cluster
pval <- toString(go_list[[cluster]][["result"]][["p_values"]][1:5])
#Extracting the p-values for the corresponding top 5 term names
nodes <- paste(go_list[[cluster]][["meta"]][["query_metadata"]][["queries"]][["query_1"]],collapse=",")
nnodes <- str_count(toString(go_list[[cluster]][["meta"]][["query_metadata"]][["queries"]][["query_1"]]),"\\S+")
#Extracing the number of nodes/genes contained in each cluster
result_df <- data.frame(
gLayCluster = cluster,
GO_Terms = terms,
GO_Pvals = pval,
Nodes = nodes,
N_nodes = nnodes
)
}
topterms_df <- do.call(rbind, lapply(names(go_list),get_top_terms))
#Getting top 5 term names and corresponding p-values for each cluster and storing in topterms_df
topterms_df <- cbind(topterms_df,sources_count,cnvassociated_count)
#joining the cluster table and the table detailing the amount of sources per cluster
write.table(topterms_df, file=paste0(getwd(),"/Data/GO-clusters-vis.tsv"), sep = "\t",row.names=FALSE,quote=FALSE)
#Writing the table to file for Cytoscape import during visualisation
loadTableData(topterms_df,data.key.column="gLayCluster",table.key.column="gLayCluster")
#Loading the generated top terms and p-values back to the supernetwork; every gene belonging to cluster x is now associated with the top terms of cluster x
deleteTableColumn('gLayCluster.1')
#Deleting duplicate gLayCluster column that appears after importing top terms data back to network
renameNetwork(title=paste0(getNetworkName(),"_GO"))
snw_scz_filtered_string_clustered_go <- getNetworkName()
#Renaming and saving the network name to indicate addition of GO information
compare_term_id_lists <- function(list1, list2) {
common_elements <- intersect(list1, list2)
return(length(common_elements))
}
#Setting up a function to get intersections between cluster term IDs
match_df <- data.frame(Cluster1 = character(),
Cluster2 = character(),
Matches = numeric(),
stringsAsFactors = FALSE)
#Setting up a df to store output in
for (i in 1:(length(go_list) - 1)) {
for (j in (i + 1):length(go_list)) {
term_id_i <- go_list[[i]][["result"]][["term_id"]]
term_id_j <- go_list[[j]][["result"]][["term_id"]]
matches <- compare_term_id_lists(term_id_i, term_id_j)
match_df <- rbind(match_df, data.frame(Cluster1 = names(go_list)[i],
Cluster2 = names(go_list)[j],
Matches = matches))
#Iterating over go_list to compare GO term IDs between every cluster and store number of overlaps
}
}
colnames(match_df) <- c("source","target","GO_term_matches")
#Renaming columns
write.table(match_df, file=paste0(getwd(),"/Data/match_df.tsv"), sep = "\t",row.names=FALSE,quote=FALSE)
exportNetwork(filename=paste0(nw_savepath,"SCZ_SNW_STRING_clustered_GO"),"CX",network=snw_scz_filtered_string_clustered_go,overwriteFile=TRUE)
#Exporting the filtered, stringified, clustered supernetwork after GO as cx file and tagging it with the time and data to match with the metadata file
end_section("GO Analysis")
##AOP ---------------------------------------------------------------------------------------------------------------------------
start_section("AOP")
aopprocess <- function(input,tag) {
if (!"SCZ_SNW_STRING_clustered_GO" %in% getNetworkList()) {
importNetworkFromFile(file=paste0(nw_savepath,"SCZ_SNW_STRING_clustered_GO.cx"))
commandsRun('table delete column column="gLayCluster.2" table="SCZ_SNW_STRING_clustered_GO default node')
createColumnFilter(
filter.name = "has_GO_result",
column = "N_nodes",
criterion = 0,
predicate = "GREATER_THAN",
anyMatch = TRUE,
apply = TRUE
)
#Selecting nodes included in a 'valid' cluster, i.e. clusters with 5 or more nodes (GO analysis only performed for these)
#N_nodes is only generated for 'valid' clusters, so good column to filter by
invertNodeSelection()
deleteSelectedNodes()
#Inverting the selection and deleting these nodes: now, the network contains only the nodes that make up the clusters fed into the GO analysis
#Nodes not associated to a large enough cluster/GO term are likely not involved in any significant SCZ-contributing way
#The idea is to link GO terms (formed by clusters/genes) to risk factors, so it wouldn't make sense to also link non-cluster/GO associated nodes
}
else {
commandsRun('table delete column column="gLayCluster.2" table="SCZ_SNW_STRING_clustered_GO default node')
createColumnFilter(
filter.name = "has_GO_result",
column = "N_nodes",
criterion = 0,
predicate = "GREATER_THAN",
anyMatch = TRUE,
apply = TRUE
)
#Selecting nodes included in a 'valid' cluster, i.e. clusters with 5 or more nodes (GO analysis only performed for these)
#N_nodes is only generated for 'valid' clusters, so good column to filter by
invertNodeSelection()
deleteSelectedNodes()
#Inverting the selection and deleting these nodes: now, the network contains only the nodes that make up the clusters fed into the GO analysis
#Nodes not associated to a large enough cluster/GO term are likely not involved in any significant SCZ-contributing way
#The idea is to link GO terms (formed by clusters/genes) to risk factors, so it wouldn't make sense to also link non-cluster/GO associated nodes
}
#Reimporting the network with GO information back to Cytoscape if needed
#Running aopprocess causes all changes to be applied to the GO network
#Running aopprocess a second time with other parameters would thus compound changes into the same network which is undesired
sparqlquery("AOP-Wiki",input,"keensgpairs")
#Querying AOP-Wiki for a list of all KEs and associated genes. KEs must be contained in an AOP that has an AO from a list of selected AOs
#Explicity listing keensgpairs so that it is caught by ls()
for (i in 1:ncol(keensgpairs)) {
for (j in 1:nrow(keensgpairs)) {
keensgpairs[j, i] <- gsub('"', '', keensgpairs[j, i])
}
}
#Removing quotation marks from the df
separate_keensgpairs <- separate_rows(keensgpairs,Ensembl,sep="; ")
#Dividing comma-separated Ensembl IDs into distinct rows
keensgpairs_byensg <- separate_keensgpairs %>%
group_by(Ensembl) %>%
summarise(KEid = paste(KEid, collapse="; "),
KE_title = paste(KEtitle, collapse="; "),
AOid = paste(AOid, collapse="; "),
AO_title = paste(AOtitle, collapse = "; "),
AOPid = paste(AOPid, collapse="; "),
AOP_title =paste(AOPtitle, collapse="; "))
#Concateinating other variables based on unique Ensembl ID to get list of associated KEs, AOs, and AOPs per gene
keensgpairs_byensg_save <- paste0(getwd(),sprintf("/Data/AOP-Wiki/keensgpairs_byensg_%s.tsv",tag))
#Defining savepath for newly generated df
write.table(keensgpairs_byensg, file=keensgpairs_byensg_save,quote=FALSE, sep="\t", row.names=FALSE)
#Saving df containing gene-KE-AO-AOP associations to file as tsv for Cytoscape import
commandsRun(sprintf('table import file dataTypeTargetforNetworkCollection="Node Table Columns" delimiters=\\t file=%s firstRowAsColumnNames=true keyColumnForMapping="Ensembl" keyColumnIndex=1 startLoadRow=1',keensgpairs_byensg_save))
#Importing the gene-KE-AO-AOP table to Cytoscape as table add AOP-Wiki info as node attributes
renameNetwork(paste0(getNetworkName(),"_AOP"))
scz_snw_string_go_aop <- getNetworkName()
commandsRun(sprintf('table export options=CSV outputFile=%s table="SCZ_SNW_STRING_clustered_GO_AOP default  node"',paste0(other_savepath,"SCZ_SNW_STRING_GO_AOP default node","_",tag)))
#Exporting the network table
scz_snw_string_go_aop_node <- read.csv(file=paste0(other_savepath,"SCZ_SNW_STRING_GO_AOP default node","_",tag,".csv"),header=TRUE)
#Reading the exported table as Cytoscape object
aop_associated_genes <- scz_snw_string_go_aop_node[!(scz_snw_string_go_aop_node$KEid == ""), , drop=FALSE]
#Getting which rows (=gene nodes) have info from AOP-Wiki associated to them
renameNetwork(paste0(getNetworkName(),"_",tag))
summary_go_terms <- read.delim(paste0(getwd(),"/Data/summary_go_terms.txt"),header=TRUE,sep="\t",quote="")
#Loading cluster titles based on GO terms
aop_associated_genes <- merge(aop_associated_genes,summary_go_terms,"gLayCluster")
separate_aoptitles <- separate_rows(aop_associated_genes,AOP_title,sep="; ")
aop_freq_table <- table(separate_aoptitles$AOP_title)
aop_freq_df <- as.data.frame(aop_freq_table)
add_attributes <- separate_aoptitles %>%
group_by(AOP_title) %>%
summarise (AOPEnsembl = paste(Ensembl,collapse="; "),
AOPgenename = paste(Name2, collapse="; "),
AOPsummary_go_term = paste(summary_term, collapse="; "))
names(aop_freq_df) <- c("AOP_title","AOP_frequency")
aop_freq_df_full <- merge(aop_freq_df, add_attributes,"AOP_title")
#Counting how often which AOPs are associated with all genes
separate_aotitles <- separate_rows(aop_associated_genes,AO_title,sep="; ")
ao_freq_table <- table(separate_aotitles$AO_title)
ao_freq_df <- as.data.frame(ao_freq_table)
add_attributes <- separate_aotitles %>%
group_by(AO_title) %>%
summarise (AOEnsembl = paste(Ensembl,collapse="; "),
AOgenename = paste(Name2, collapse="; "),
AOsummary_go_term = paste(summary_term, collapse="; "))
names(ao_freq_df) <- c("AO_title","AO_frequency")
ao_freq_df_full <- merge(ao_freq_df, add_attributes,"AO_title")
#Counting how often which AOs are associated with all genes
separate_ketitles <- separate_rows(aop_associated_genes,KE_title,sep="; ")
ke_freq_table <- table(separate_ketitles$KE_title)
ke_freq_df <- as.data.frame(ke_freq_table)
add_attributes <- separate_ketitles %>%
group_by(KE_title) %>%
summarise (KEEnsembl = paste(Ensembl,collapse="; "),
KEgenename = paste(Name2, collapse="; "),
KEsummary_go_term = paste(summary_term, collapse="; "))
names(ke_freq_df) <- c("KE_title","KE_frequency")
ke_freq_df_full <- merge(ke_freq_df, add_attributes,"KE_title")
#Counting how often which KEs are associated with all genes
aop_associated_genes_freq <- bind_rows(aop_freq_df_full,ao_freq_df_full,ke_freq_df_full)
aop_link <- list()
variables <- ls()
#Getting a list of variables defined within the aopprocess function
#append_suffix <- function(variable, suffix) {
#assign(paste0(variable,"_",suffix), get(variable), envir = .GlobalEnv)
#}
#Defining a function to add a suffix to the variables created within the aopprocess function
for (variable in variables) {
aop_link[[variable]] <- get(variable)
}
return(aop_link)
#Appending the given tag to every produced variable within the aopprocess function
#Saving the resulting network
}
#Because a comparison should be made between selection criteria of the AOP-Wiki query,
#the aopprocess function is used to be more flexible in defining the query file
#as well as the suffix that is to be added so that the type of filter/query can be traced back
aoplink_selected <- aopprocess("AO_KE_Ensembl_query.txt","selected")
#Matching AOP information to risk genes in the network from selected adverse outcomes relating to neuronal development and psychiatric outcomes
snw_scz_string_clustered_GO_AOP_selected <- getNetworkName()
exportNetwork(filename=paste0(nw_savepath,"SCZ_SNW_STRING_clustered_GO_AOP_selected"),"CX",network=snw_scz_string_clustered_GO_AOP_selected,overwriteFile=TRUE)
#Exporting network
aoplink_all <- aopprocess("all_AO_KE_Ensembl_query.txt","all")
#Matching AOP information to risk genes in the network from all AOs available in AOP-Wiki
snw_scz_string_clustered_GO_AOP_all <- getNetworkName()
exportNetwork(filename=paste0(nw_savepath,"SCZ_SNW_STRING_clustered_GO_AOP_all"),"CX",network=snw_scz_string_clustered_GO_AOP_all,overwriteFile=TRUE)
#Exporting network
gettop <- function(input) {
freq_df <- input$aop_associated_genes_freq
cutoff_aop <- quantile(freq_df$AOP_frequency, probs=0.75,na.rm = TRUE)
#Defining cutoff for AOP frequency (top 25% most frequent)
topquarter_aop <- freq_df[freq_df$AOP_frequency >= cutoff_aop & !is.na(freq_df$AOP_frequency),1:5,drop=FALSE]
#Selecting the top 25% most frequently matched with AOPs and associated information
cutoff_ao <- quantile(freq_df$AO_frequency, probs=0.75,na.rm = TRUE)
#Defining cutoff for AO frequency (top 25% most frequent)
topquarter_ao <- freq_df[freq_df$AO_frequency >= cutoff_ao & !is.na(freq_df$AO_frequency),6:10,drop=FALSE]
#Selecting the top 25% most frequently matched with AOs and associated information
cutoff_ke <- quantile(freq_df$KE_frequency, probs=0.75,na.rm = TRUE)
#Defining cutoff for KE frequency (top 25% most frequent)
topquarter_ke <- freq_df[freq_df$KE_frequency >= cutoff_ke & !is.na(freq_df$KE_frequency),11:15,drop=FALSE]
#Selecting the top 25% most frequently matched with KEs and associated information
top_aopwiki <- list(topquarter_aop=topquarter_aop,topquarter_ao=topquarter_ao,topquarter_ke=topquarter_ke)
}
top_selected <- gettop(aoplink_selected)
top_all <- gettop(aoplink_all)
topquarter_ke <- top_selected$topquarter_ke
topquarter_ke_sep <- separate_rows(topquarter_ke,KEEnsembl,sep="; ")
mergedkeensg <- union(topquarter_ke_sep$KE_title,topquarter_ke_sep$KEEnsembl)
topquarter_ke_node <- data.frame(combined=mergedkeensg)
topquarter_ke_edge <- topquarter_ke_sep[,c("KE_title","KEEnsembl")]
write.table(topquarter_ke_node, file=paste0(getwd(),"/topquarter_ke_node.tsv"),sep="\t",quote=FALSE,row.names=FALSE)
write.table(topquarter_ke_edge, file=paste0(getwd(),"/topquarter_ke_edge.tsv"),sep="\t",quote=FALSE,row.names=FALSE)
end_section("AOP")
#write.table(topquarter_ke_node, file=paste0(getwd(),"/topquarter_ke_node.tsv"),sep="\t",quote=FALSE,row.names=FALSE)
write.table(topquarter_ke_edge, file=paste0(other_savepath,"/topquarter_ke_edge.tsv"),sep="\t",quote=FALSE,row.names=FALSE)
?importNetworkFromFile
makecytable <- function(input) {
topquarter_ke <- input$topquarter_ke
topquarter_ke_sep <- separate_rows(topquarter_ke,KEEnsembl,sep="; ")
mergedkeensg <- union(topquarter_ke_sep$KE_title,topquarter_ke_sep$KEEnsembl)
#topquarter_ke_node <- data.frame(combined=mergedkeensg)
topquarter_ke<- topquarter_ke_sep[,c("KE_title","KEEnsembl")]
#write.table(topquarter_ke_node, file=paste0(getwd(),"/topquarter_ke_node.tsv"),sep="\t",quote=FALSE,row.names=FALSE)
write.table(topquarter_ke, file=paste0(other_savepath,sprintf("/topquarter_ke_edge%s.tsv",sub("aoplink","",input))),sep="\t",quote=FALSE,row.names=FALSE)
#Writing the KE-gene table to file for Cytoscape import
commandsRun(sprintf('network import file columnTypeList=s,t delimiters=\\t file=%s firstRowAsColumnNames=true rootNetworkList=-- Create new network collection -- startLoadRow=1'),paste0(other_savepath,sprintf("/topquarter_ke_edge%s.tsv",sub("aoplink","",input))))
}
makecytable(aoplink_all)
top_all <- gettop(aoplink_all)
View(top_all)
makecytable(aoplink_all)
View(aoplink_all)
makecytable(top_all)
paste0(other_savepath,sprintf("/topquarter_ke_edge%s.tsv",sub("aoplink","",input)))
makecytable <- function(input) {
topquarter_ke <- input$topquarter_ke
topquarter_ke_sep <- separate_rows(topquarter_ke,KEEnsembl,sep="; ")
mergedkeensg <- union(topquarter_ke_sep$KE_title,topquarter_ke_sep$KEEnsembl)
#topquarter_ke_node <- data.frame(combined=mergedkeensg)
topquarter_ke<- topquarter_ke_sep[,c("KE_title","KEEnsembl")]
#write.table(topquarter_ke_node, file=paste0(getwd(),"/topquarter_ke_node.tsv"),sep="\t",quote=FALSE,row.names=FALSE)
write.table(topquarter_ke, file=paste0(other_savepath,sprintf("/topquarter_ke_edge%s.tsv",sub("top","",input))),sep="\t",quote=FALSE,row.names=FALSE)
#Writing the KE-gene table to file for Cytoscape import
commandsRun(sprintf('network import file columnTypeList=s,t delimiters=\\t file=%s firstRowAsColumnNames=true rootNetworkList=-- Create new network collection -- startLoadRow=1'),paste0(other_savepath,sprintf("/topquarter_ke_edge%s.tsv",sub("aoplink","",input))))
}
makecytable(top_all)
paste0(other_savepath,sprintf("/topquarter_ke_edge%s.tsv",sub("top","",top_all)))
makecytable <- function(input) {
topquarter_ke <- input$topquarter_ke
topquarter_ke_sep <- separate_rows(topquarter_ke,KEEnsembl,sep="; ")
mergedkeensg <- union(topquarter_ke_sep$KE_title,topquarter_ke_sep$KEEnsembl)
#topquarter_ke_node <- data.frame(combined=mergedkeensg)
topquarter_ke<- topquarter_ke_sep[,c("KE_title","KEEnsembl")]
#write.table(topquarter_ke_node, file=paste0(getwd(),"/topquarter_ke_node.tsv"),sep="\t",quote=FALSE,row.names=FALSE)
write.table(topquarter_ke, file=paste0(other_savepath,sprintf("/topquarter_ke_edge%s.tsv",sub("top","",deparse(substitute(input))))),sep="\t",quote=FALSE,row.names=FALSE)
#Writing the KE-gene table to file for Cytoscape import
commandsRun(sprintf('network import file columnTypeList=s,t delimiters=\\t file=%s firstRowAsColumnNames=true rootNetworkList=-- Create new network collection -- startLoadRow=1'),paste0(other_savepath,sprintf("/topquarter_ke_edge%s.tsv",sub("aoplink","",input))))
}
makecytable(top_all)
makecytable <- function(input) {
topquarter_ke <- input$topquarter_ke
topquarter_ke_sep <- separate_rows(topquarter_ke,KEEnsembl,sep="; ")
mergedkeensg <- union(topquarter_ke_sep$KE_title,topquarter_ke_sep$KEEnsembl)
#topquarter_ke_node <- data.frame(combined=mergedkeensg)
topquarter_ke<- topquarter_ke_sep[,c("KE_title","KEEnsembl")]
#write.table(topquarter_ke_node, file=paste0(getwd(),"/topquarter_ke_node.tsv"),sep="\t",quote=FALSE,row.names=FALSE)
write.table(topquarter_ke, file=paste0(other_savepath,sprintf("/topquarter_ke_edge%s.tsv",sub("top","",deparse(substitute(input))))),sep="\t",quote=FALSE,row.names=FALSE)
#Writing the KE-gene table to file for Cytoscape import
commandsRun(sprintf('network import file columnTypeList=s,t delimiters=\\t file=%s firstRowAsColumnNames=true rootNetworkList=-- Create new network collection -- startLoadRow=1'),paste0(other_savepath,sprintf("/topquarter_ke_edge%s.tsv",sub("top","",deparse(substitute(input))))))
}
makecytable <- function(input) {
topquarter_ke <- input$topquarter_ke
topquarter_ke_sep <- separate_rows(topquarter_ke,KEEnsembl,sep="; ")
mergedkeensg <- union(topquarter_ke_sep$KE_title,topquarter_ke_sep$KEEnsembl)
#topquarter_ke_node <- data.frame(combined=mergedkeensg)
topquarter_ke<- topquarter_ke_sep[,c("KE_title","KEEnsembl")]
#write.table(topquarter_ke_node, file=paste0(getwd(),"/topquarter_ke_node.tsv"),sep="\t",quote=FALSE,row.names=FALSE)
write.table(topquarter_ke, file=paste0(other_savepath,sprintf("/topquarter_ke_edge%s.tsv",sub("top","",deparse(substitute(input))))),sep="\t",quote=FALSE,row.names=FALSE)
#Writing the KE-gene table to file for Cytoscape import
commandsRun(sprintf('network import file columnTypeList=s,t delimiters=\\t file=%s firstRowAsColumnNames=true rootNetworkList=-- Create new network collection -- startLoadRow=1'),paste0(other_savepath,sprintf("/topquarter_ke_edge%s.tsv",sub("top","",deparse(substitute(input))))))
}
makecytable(top_all)
makecytable <- function(input) {
topquarter_ke <- input$topquarter_ke
topquarter_ke_sep <- separate_rows(topquarter_ke,KEEnsembl,sep="; ")
mergedkeensg <- union(topquarter_ke_sep$KE_title,topquarter_ke_sep$KEEnsembl)
#topquarter_ke_node <- data.frame(combined=mergedkeensg)
topquarter_ke<- topquarter_ke_sep[,c("KE_title","KEEnsembl")]
#write.table(topquarter_ke_node, file=paste0(getwd(),"/topquarter_ke_node.tsv"),sep="\t",quote=FALSE,row.names=FALSE)
write.table(topquarter_ke, file=paste0(other_savepath,sprintf("/topquarter_ke_edge%s.tsv",sub("top","",deparse(substitute(input))))),sep="\t",quote=FALSE,row.names=FALSE)
#Writing the KE-gene table to file for Cytoscape import
commandsRun(sprintf('network import file columnTypeList=s,t delimiters=\\t file=%s firstRowAsColumnNames=true rootNetworkList=-- Create new network collection -- startLoadRow=1',paste0(other_savepath,sprintf("/topquarter_ke_edge%s.tsv",sub("top","",deparse(substitute(input)))))))
}
makecytable(top_all)
makecytable <- function(input) {
topquarter_ke <- input$topquarter_ke
topquarter_ke_sep <- separate_rows(topquarter_ke,KEEnsembl,sep="; ")
mergedkeensg <- union(topquarter_ke_sep$KE_title,topquarter_ke_sep$KEEnsembl)
#topquarter_ke_node <- data.frame(combined=mergedkeensg)
topquarter_ke<- topquarter_ke_sep[,c("KE_title","KEEnsembl")]
#write.table(topquarter_ke_node, file=paste0(getwd(),"/topquarter_ke_node.tsv"),sep="\t",quote=FALSE,row.names=FALSE)
write.table(topquarter_ke, file=paste0(other_savepath,sprintf("/topquarter_ke_edge%s.tsv",sub("top","",deparse(substitute(input))))),sep="\t",quote=FALSE,row.names=FALSE)
#Writing the KE-gene table to file for Cytoscape import
commandsRun(sprintf('network import file columnTypeList=s,t delimiters=\\t file=%s firstRowAsColumnNames=true rootNetworkList=-- Create new network collection -- startLoadRow=1',paste0(other_savepath,sprintf("/topquarter_ke_edge%s.tsv",sub("top","",deparse(substitute(input)))))))
renameNetwork(sprintf("Top 25% key events - risk genes %s",sub("top","",deparse(substitute(input)))))
}
makecytable(top_all)
makecytable <- function(input) {
topquarter_ke <- input$topquarter_ke
topquarter_ke_sep <- separate_rows(topquarter_ke,KEEnsembl,sep="; ")
mergedkeensg <- union(topquarter_ke_sep$KE_title,topquarter_ke_sep$KEEnsembl)
#topquarter_ke_node <- data.frame(combined=mergedkeensg)
topquarter_ke<- topquarter_ke_sep[,c("KE_title","KEEnsembl")]
#write.table(topquarter_ke_node, file=paste0(getwd(),"/topquarter_ke_node.tsv"),sep="\t",quote=FALSE,row.names=FALSE)
write.table(topquarter_ke, file=paste0(other_savepath,sprintf("/topquarter_ke_edge%s.tsv",sub("top","",deparse(substitute(input))))),sep="\t",quote=FALSE,row.names=FALSE)
#Writing the KE-gene table to file for Cytoscape import
commandsRun(sprintf('network import file columnTypeList=s,t delimiters=\\t file=%s firstRowAsColumnNames=true rootNetworkList=-- Create new network collection -- startLoadRow=1',paste0(other_savepath,sprintf("/topquarter_ke_edge%s.tsv",sub("top","",deparse(substitute(input)))))))
Sys.sleep(0.5)
renameNetwork(sprintf("Top 25% key events - risk genes %s",sub("top","",deparse(substitute(input)))))
}
makecytable(top_all)
makecytable <- function(input) {
topquarter_ke <- input$topquarter_ke
topquarter_ke_sep <- separate_rows(topquarter_ke,KEEnsembl,sep="; ")
mergedkeensg <- union(topquarter_ke_sep$KE_title,topquarter_ke_sep$KEEnsembl)
#topquarter_ke_node <- data.frame(combined=mergedkeensg)
topquarter_ke<- topquarter_ke_sep[,c("KE_title","KEEnsembl")]
#write.table(topquarter_ke_node, file=paste0(getwd(),"/topquarter_ke_node.tsv"),sep="\t",quote=FALSE,row.names=FALSE)
write.table(topquarter_ke, file=paste0(other_savepath,sprintf("/topquarter_ke_edge%s.tsv",sub("top","",deparse(substitute(input))))),sep="\t",quote=FALSE,row.names=FALSE)
#Writing the KE-gene table to file for Cytoscape import
commandsRun(sprintf('network import file columnTypeList=s,t delimiters=\\t file=%s firstRowAsColumnNames=true rootNetworkList=-- Create new network collection -- startLoadRow=1',paste0(other_savepath,sprintf("/topquarter_ke_edge%s.tsv",sub("top","",deparse(substitute(input)))))))
Sys.sleep(0.5)
renameNetwork(sprintf("Top quarter key events - risk genes %s",sub("top","",deparse(substitute(input)))))
}
makecytable(top_all)
makecytable(top_selected)
