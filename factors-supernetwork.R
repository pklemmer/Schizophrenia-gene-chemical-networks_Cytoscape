## SETUP -----------------------------------------------------------------------------------------------------------------------

#Requires R 4.3.2 and Rtools 4.3
#dplyr 1.1.4; httr 1.4.7; BiocManager 1.30.22; rWikiPathways 1.22.1; RCy3 2.22.1
#Cytoscape 3.10.1

setwd("~/GitHub/SCZ-CNV")
  #Setting working directory
rm(list=ls())
  #Cleaning up workspace
packages <- c("dplyr","httr","stringr","gprofiler2")
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages])
}
if(!"rWikiPathways" %in% installed.packages()){
  if (!requireNamespace("BiocManager", quietly=TRUE))
    install.packages("BiocManager")
  BiocManager::install("rWikiPathways")
}
if(!"RCy3" %in% installed.packages()){
  if (!requireNamespace("BiocManager", quietly=TRUE))
    install.packages("BiocManager")
  BiocManager::install("RCy3")
}
  #Checking if required packages are installed and installing if not
  #Different structure for rWikiPathways and RCy3 packages as these are not installed directly but via the BiocManager package
invisible(lapply(c(packages,"rWikiPathways","RCy3"), require, character.only = TRUE))
  #Loading libraries

sysdatetime <- Sys.time()
datetime <- format(sysdatetime, format = "%Y-%m-%d_%Hh%M")
dir.create("Outputs")
dir.create(sprintf("Outputs/Session-%s",datetime))
dir.create(sprintf("Outputs/Session-%s/Networks",datetime))
  #Creating directories for outputs generated by this script to be saved in; new "Session" folder created each time the script is ran (contains generated networks, metadata, and sessionInfo)
nw_savepath <- sprintf("%1$s/Outputs/Session-%2$s/Networks/",getwd(),datetime)
file.create(sprintf("Outputs/Session-%s/metadata.txt",datetime))
  #Creating a new metadata file with the current date and time as suffix for easier organisation
  #Such a metadata file should be generated every time this script is ran to record parameters and versions of functions or databases, including the time avoids files being overwritten if the script is run multiple times a day (can even include seconds if script is ran multiple times per minute)
metadata.add <- function(info) {
  write(sapply(info, as.character), sprintf("Outputs/Session-%s/metadata.txt",datetime),append=TRUE, sep = "\n")
}
metadata.add(sysdatetime)
metadata.add(Sys.timezone())
metadata.add("")
  #Adding the timezone, date, and time to the metadata 

invisible(file.create(sprintf("Outputs/Session-%s/sessioninfo-%s.txt",datetime,datetime)))
writeLines(capture.output(sessionInfo()),sprintf("Outputs/Session-%s/sessioninfo-%s.txt",datetime,datetime))
  #Generating and adding a sessionInfo file to the current session output folder

cytoscapePing()
cytoscapeVersionInfo()
  #Checking if Cytoscape is running and version info
metadata.add(capture.output(cytoscapeVersionInfo()))

checkinstall.app <- function(app) {
  status_string <- getAppStatus(app)
  #Getting install status of app
  words <- strsplit(status_string, " ")[[1]]
  last_word <- tail(words, 1)
  #getAppStatus returns a character string instead of a logical value, so the last word (usually either "Installed" or "Uninstalled") from the output is checked
  if (last_word == "Installed") {
    print(sprintf("App %s is already installed.",app))
  } else {
    installApp(app)
    print(sprintf("Installed app %s.",app))
  }
}
  #Function to check whether required Cytoscape apps are installed and installing them if not
applist <- c("Wikipathways", "DisGeNET-app", "CyTargetLinker","stringApp","BridgeDb","clusterMaker2")
  #WikiPathways v.3.3.10
  #DisGeNET-app v.7.3.0
  #CyTargetLinker v. 4.1.0
  #stringApp v. 2.0.1
  #BridgeDb v.1.2.0
  #clusterMaker2 v.2.3.4
lapply(applist,checkinstall.app)
  #Checking and installing (if required) necessary Cytoscape apps
lapply(applist,getAppInformation)
metadata.add("Required Cytoscape apps and versions:")
invisible(metadata.add(print(lapply(applist,getAppInformation))))
metadata.add("")

# FUNCTION DICTIONARY-------------------------------------------------------------------------------------------------------------------
.defaultBaseUrl <- 'http://127.0.0.1:1234/v1'
  #Defining the default base URL found in the RCy3 source as R object for altmergeNetworks
altmergeNetworks <- function(               sources = NULL,
                                            title = NULL,
                                            operation = "union",
                                            nodeKeys = NULL,
                                            nodeMergeMap = NULL,
                                            nodesOnly = FALSE,
                                            edgeKeys = NULL,
                                            edgeMergeMap = NULL,
                                            networkMergeMap = NULL,
                                            inNetworkMerge = TRUE,
                                            base.url = .defaultBaseUrl) {
  cmd.string <- 'network merge' # a good start
  
  # sources must be suppled
  if(is.null(sources)) {
    message("Missing sources!")
    return(NULL)
  } else {
    sources.str <- paste(sources, collapse = ",")
    cmd.string <- paste0(cmd.string,' sources="',sources.str,'"')
  }
  
  # defaults
  cmd.string <- paste0(cmd.string,' operation=',operation)
  cmd.string <- paste0(cmd.string,' nodesOnly=',nodesOnly)
  cmd.string <- paste0(cmd.string,' inNetworkMerge=',inNetworkMerge)
  
  # optional args
  if(!is.null(title))
    cmd.string <- paste0(cmd.string,' netName="',title,'"')
  if(!is.null(nodeKeys))
    cmd.string <- paste0(cmd.string,' nodeKeys="',paste(nodeKeys, collapse = ","),'"')
  if(!is.null(edgeKeys))
    cmd.string <- paste0(cmd.string,' edgeKeys="',paste(edgeKeys, collapse = ","),'"')
  if(!is.null(nodeMergeMap)){
    nodeMergeMap.str <- paste(nodeMergeMap, collapse = ",")
    nodeMergeMap.str <- gsub("c\\(", "{", nodeMergeMap.str)
    nodeMergeMap.str <- gsub("\\)", "}", nodeMergeMap.str)
    cmd.string <- paste0(cmd.string,' nodeMergeMap="',nodeMergeMap.str,'"')
  }
  if(!is.null(edgeMergeMap)){
    edgeMergeMap.str <- paste(edgeMergeMap, collapse = ",")
    edgeMergeMap.str <- gsub("c\\(", "{", edgeMergeMap.str)
    edgeMergeMap.str <- gsub("\\)", "}", edgeMergeMap.str)
    cmd.string <- paste0(cmd.string,' edgeMergeMap="',edgeMergeMap.str,'"')
  }
  if(!is.null(networkMergeMap)){
    networkMergeMap.str <- paste(networkMergeMap, collapse = ",")
    networkMergeMap.str <- gsub("c\\(", "{", networkMergeMap.str)
    networkMergeMap.str <- gsub("\\)", "}", networkMergeMap.str)
    cmd.string <- paste0(cmd.string,' networkMergeMap="',networkMergeMap.str,'"')
  }
  
  res.data <- commandsPOST(cmd.string, base.url = base.url)
  
  if(!is.null(res.data$SUID))
    return(res.data$SUID)
  else
    return(res.data)
}
  #Normally, RCy3's 'mergeNetworks' function would be used to unify imported networks into one supernetwork
  #This function does however not work on the latest RCy3 release (v.2.22.1), but does work when running the script on RCy3 v.2.14.2
  #RCy3 2.14.2 requires R v.4.1.3, requiring the entire script to run on an old version of R for one function that is used once
  #Here, we redefine the function using the source code from RCy3 v.2.14.2 and simply use this alternate function to merge networks

queryspecies.wp <- c("Homo sapiens","Rattus norvegicus","Mus musculus")
getPathways.wp <- function(i) {
  pw <- findPathwaysByText(i)
  pw <- pw %>%
    dplyr::filter(species %in% queryspecies.wp)
    #Filtering by species
  pw.ids <- paste0(i, "_wpids")
  assign(pw.ids, as.character(pw$id),envir = .GlobalEnv)
    #Extracting WP IDs
}
  #Function to query WikiPathways using keyword and to extract WP IDs for the import function

createNodeSource <- function(source,doi=NULL) {
  if (source == "WikiPathways") {
    networkname <- getNetworkName()
    nodetable <- paste0(networkname," default  node") 
  } 
    #Networks imported from WikiPathways have a type in the node table designations, as they have 2 spaces between "default" and "node" instead of one
    #This check determines which node table name format is to be applied depending on the source (WikiPathways or other)
  else {
    networkname <- getNetworkName()
    nodetable <- paste0(networkname," default node") 
  }
  commandsRun(sprintf("table create column columnName=WikiPathways table=%s type=string",nodetable))
  commandsRun(sprintf("table create column columnName=DisGeNET table=%s type=string",nodetable))
  commandsRun(sprintf("table create column columnName=Literature table=%s type=string",nodetable))
  commandsRun(sprintf("table create column columnName=Literature.doi table=%s type=string",nodetable))
  commandsRun(sprintf("table create column columnName=STRINGnode table=%s type=string",nodetable))
    #Creating a new column for each source used for all networks
  commandsRun(sprintf("table set values columnName=%1$s handleEquations=false rowList=all table=%2$s value=1",source,nodetable))
    #Filling the new column of the corresponding source with 1 to indicate which source the node is imported from 
  if (!is.null(doi)) {
    commandsRun(sprintf("table set values columnName=Literature.doi handleEquations=false rowList=all table=%1$s value=%2$s",nodetable,doi))
    #Adding doi for literature used if provided
  }
}
  #Function to create new column in node table specifying origin of network/node

import <- function(j) {
  commandsRun(paste0('wikipathways import-as-network id=', j))
    #Pasting WikiPathways IDs into a Cytoscape command line prompt to import as networks
  createNodeSource("WikiPathways")
    #Filling the 'WikiPathways' column with 1 to indicate the source
}
  #Importing pathways from WikiPathways by pathway ID

disgenetRestUrl<-function(netType,host="127.0.0.1",port=1234,version="v7"){
  if(is.null(netType)){
    print("Network type not specified.")
  }else{
    disgeneturl<-sprintf("http://%s:%i/disgenet/%s/%s",host,port,version,netType)
  }
  return (disgeneturl)
}
net <- "gene-disease-net"
disgenetRestUrl(netType = net)
  #Defining object for REST to call DisGeNET automation module; defining that we will be using gene-disease associations (GDA)
disgenetRestCall<-function(netType,netParams){
  disgeneturl<-disgenetRestUrl(netType)
  restCall<-POST(disgeneturl, body = netParams, encode = "json")
  result<-content(restCall,"parsed")
  return(result)
}
  #Object that executes REST calls to DisGeNET module in Cytoscape 
geneDisParams <- function(source,dis,min) {list(
  source = source,
  assocType = "Any",
  diseaseClass = "Any",
  diseaseSearch = dis,
  geneSearch = " ",
  initialScoreValue = min,
  finalScoreValue = "1.0"
)}
  #Specifying parameters of the GDA network to be imported
# ADDICTION ===========================================================================================================================































## IMPORTING AND MERGING --------------------------------------------------------------------------------------------------------------
genedisparams.adc.df <- read.table("CSVs/disgenetparams-adc.txt",header=TRUE,sep = "\t")
  #Loading relevant gene-disease networks from DisGeNET
  #Networks of interest manually added into tsv where it is easier to adjust filters
disgeneturl <- c()
  #Preparing container for DisGeNET URL to be saved for addition to metadata file
apply(genedisparams.adc.df,1,function(row) {
  gdp <- geneDisParams(row["source"],row["dis"],row["min"])
  disgeneturl <<- disgenetRestUrl(net)
    #Fetching the DisGeNET URL used to make this call 
  geneDisResult <- disgenetRestCall(net,gdp)
    #Executing the DisGeNET query
  createNodeSource("DisGeNET")
    #Adding information about data source to each node
  mapTableColumn("geneName","Human","HGNC","Ensembl")
    #Mapping the HGNC gene name from the geneName column in the node table to Ensembl identifiers
  mapTableColumn("geneName","Human","Entrez Gene","Ensembl")
    #Mapping Entrez Gene IDs to Ensembl IDs
})
  #Importing networks from DisGeNET

metadata.add(paste("DisGeNET URL:",disgeneturl))
metadata.add(paste("DisGeNET net type:",net))
metadata.add("")
  #Adding the DisGeNET URL and net type used to add networks to the metadata file

keyword.wp <- c("Dopamine","Addiction")
lapply(keyword.wp, getPathways.wp)
  #Getting WP IDs for pathways matching keywords
lapply(c(Dopamine_wpids,Addiction_wpids), import)
  #Searching relevant pathways by keyword and importing them, also adding WikiPathways as source to every node
metadata.add(paste("WikiPathways keywords:",keyword.wp))
metadata.add(paste("WikiPathways queried species:",paste(queryspecies.wp,collapse = ", ")))
  #Adding the keyword and species used to filter the WikiPathways query to the metadata file
metadata.add("")

networklist.dup <- getNetworkList()
dup.filter <- function(input,suffix) {
  filtered_list <- input[substr(input, nchar(input) - 1,nchar(input))==suffix]
}
duplicates <- dup.filter(networklist.dup,"_1")
#Getting duplicate networks (Cytoscape marks duplicate networks with a "_1" suffix to the network name)
delete.dupes <- function(nw) {
  setCurrentNetwork(nw)
  deleteNetwork()
}
lapply(duplicates,delete.dupes)
  #Selecting and deleting duplicate networks

networklist <- getNetworkList()
setCurrentNetwork(networklist[[1]])
for(i in 1:length(networklist)) tryCatch({
  current <- getNetworkName()
  mergeNetworks(c(current,networklist[[i]]), paste(current,networklist[[i]]),"union",inNetworkMerge = TRUE,nodeKeys=c("Ensembl","Ensembl"))
}, error = function(e) {
  cat("An error occured:\n")
  cat("Error message: ", conditionMessage(e),"\n")
  cat("Call stack:\n")
  print(sys.calls())
})
#Looping through the network list to merge all currently open networks with each other, creating one large unified network

renameNetwork("Addiction supernetwork")
networklist <- getNetworkList()
snw_adc <- getNetworkName()
#Getting the name of the unified network to preserve it from deletion
lapply(networklist[networklist != snw_adc ],deleteNetwork)
#Deleting all networks besides newly generated unified networks

## CTL EXTENSION -----------------------------------------------------------------------------------------------------------------------

hsa <- file.path(getwd(), "Linksets", "wikipathways-20220511-hsa-WP.xgmml")
hsa_react <- file.path(getwd(), "Linksets", "wikipathways-20220511-hsa-REACTOME.xgmml")
#Loading the WikiPathways linksets available at https://cytargetlinker.github.io/pages/linksets/wikipathways
CTLextend.cmd = paste('cytargetlinker extend idAttribute="XrefId" linkSetFiles="', hsa, ',', hsa_react, '" network=current direction=TARGETS', sep="")
commandsRun(CTLextend.cmd)
#Extending the network with previously loaded linksets
layoutNetwork()
#Adding basic network layout
snw_adc_ext <- getNetworkName()

## STRINGIFY ---------------------------------------------------------------------------------------------------------------------------
setCurrentNetwork(snw_adc)
commandsRun("string stringify column=name compoundQuery=false cutoff=0.4 includeNotMapped=false networkNoGui=current networkType='full STRING network' species='Homo sapiens'")
## PharmGKB ----------------------------------------------------------------------------------------------------------------------------
pgkb.import <- function(pgkb_id,pgkb_name) {
  pgkburl = sprintf("https://api.pharmgkb.org/v1/download/pathway/%s?format=.tsv", pgkb_id)
  pgkb_name <- paste0(pgkb_name,".tsv")
  download.file(pgkburl, sprintf("PharmGKB pathways/%s",pgkb_name))
  commandsRun(sprintf("network import file indexColumnSourceInteraction=From indexColumnTargetInteraction=To file=PharmGKB pathways/%s",pgkb_name))
}
pgkb.import("PA166170742","Antipsychotics pathway")